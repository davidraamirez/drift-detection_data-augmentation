# Imports
from io import StringIO
import io
import json
from typing import Optional, Union
from fastapi import FastAPI, Query, UploadFile, File, HTTPException
from typing import List
from fastapi.responses import StreamingResponse
import pandas as pd
import numpy as np
from scipy.stats import binom,poisson,geom,hypergeom,uniform,expon, gamma, beta,chi2,t,pareto,lognorm
import matplotlib.pyplot as plt
from skforecast.ForecasterAutoreg import ForecasterAutoreg
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, ExtraTreesRegressor
from skforecast.ForecasterAutoregDirect import ForecasterAutoregDirect
from sklearn.linear_model import Ridge
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeRegressor
from series_sinteticas.funciones_generales import series_periodos,crear_df_fin_tend_det, crear_df_periodos_tend_det,crear_df_fin_ARMA,crear_df_fin_datos,crear_df_periodos_datos,crear_df_periodos_ARMA,crear_df_fin_periodicos, crear_df_periodos_periodicos, crear_df_fin_DRIFT, crear_df_periodos_DRIFT
from aumentacion.ampliacion import normal,box_muller,duplicados, agregar_comb,traslacion,escalado,add_harmonic_noise,agregar_matematica, estadist, descomp, prediccion_sarimax, prediccion_backtesting_forecasterAutoreg, predicciones_backtesting_forecasterAutoregDirect, pred_prophet_prediccion, interpolacion_min_max, interpolacion_normal, punto_medio, interpolacion_spline
from aumentacion.variable_exog import objetivo_lineal, objetivo_polinomico, objetivo_exp,objetivo_log, multivariante, interaccion, objetivo_prop_inversa, objetivo_escalonada, objetivo_funcional, objetivo_condicional, elegir_funcion_multi,elegir_condicion, elegir_funcion, objetivo_PCA, objetivo_correlacion,objetivo_covarianza
from drift.modelos_drift import detect_dataset_drift_ks, detect_dataset_drift_js,detect_dataset_drift_psi, detect_dataset_drift_psi_quantiles, detect_dataset_drift_cusum, detect_dataset_drift_ph, detect_dataset_drift_mcusum, detect_dataset_drift_mewma, detect_dataset_drift_pC_mewma, detect_dataset_drift_hotelling
from modelos_prediccion.modelos_pred import prediccion_sarimax, error_sarimax,prediccion_backtesting_forecasterAutoreg,error_backtesting_forecasterAutoreg, predicciones_backtesting_forecasterAutoregDirect,error_backtesting_forecasterAutoregDirect,pred_prophet_prediccion,error_prophet_prediccion,pred_entrenar_linearReg,error_entrenar_linearReg,pred_entrenar_TreeReg,error_entrenar_TreeReg,pred_entrenar_RandomForestReg,error_entrenar_RandomForestReg,pred_entrenar_GradientBoostReg,error_entrenar_GradientBoostReg,pred_entrenar_ExtraTreeReg,error_entrenar_ExtraTreeReg

app = FastAPI()

@app.get("/")
def read_root():
    return {"Contenido": "Esto es una API para generar datos sintéticos a partir de ciertos parámetros, aumentación de datos, detección de drift y generación de variables objetivo."}

# Creación csv 
def pasar_csv(df):
    return df.to_csv()

# Función que realiza un plot del dataframe
def plot_df(df):
    plt.figure()
    df.plot(title="Serie temporal",figsize=(13,5))
    plt.xlabel("Tiempo")  

# reporte estadístico del modelo de tendencia determinista
@app.get("/reporte/tendencia/fin")
def obtener_reporte(inicio: str, fin:str, freq:str, tipo:int , error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float] = Query(...,description="Parametros de la tendencia")):
   """
    Devuelve un reporte estadístico del modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
   if tipo == 1:
       subtipo = "lineal"
       tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params[0]) + ", b = " +str (params[1]) +" y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"

   elif tipo ==2:
       subtipo ="polinómica de grado "+ str(len(params)-1)
       tendencia= "La serie es de tipo y = a + b[1] * t"  
       for k in range (2,len(params)):
           tendencia += " + b ["+str(k)+"] * t ** " + str(k)
       tendencia = tendencia + " + e0"
       tendencia = tendencia + " donde a = " + str(params[0]) + ", b[1] = " + str (params[1])
       for k in range (2,len(params)):
           tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params[k])
       tendencia = tendencia +" y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"
   
   elif tipo == 3: 
       subtipo ="exponencial"
       tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params[0]) + ", b = " + str(params[1]) + " y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"
   
   elif tipo == 4:
       subtipo = "logaritmica" 
       tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params[0]) + " b = " + str(params[1]) + " y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"

   tipos = "Modelo de tendencia determinista con tendencia " + subtipo
   explicacion = "Inicio: fecha de inicio " + str(inicio)
   explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
   explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
   explicacion = explicacion + ". Tipo: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo)
   explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(error)
   explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
   for k in range (1, len (columna)):
       explicacion = explicacion+", " + columna [k]
   explicacion = explicacion + ". Params: parámetros de la tendencia, a = params[0] y b[k] = params[k] --> "+str(params [0])
   for k in range (1, len (params)):
       explicacion = explicacion+", " + str(params [k])
   return {"Tipo": tipos, "Serie" : tendencia, "Parámetros" : explicacion }

# Creación de un csv con datos de una serie temporal con tendencia determinista
@app.get("/Datos/tendencia/fin")
async def obtener_datos(inicio: str, fin:str, freq:str, tipo:int , error: Union[float, None] = None, columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float] = Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un csv con los datos generados con un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
    df = crear_df_fin_tend_det(inicio,fin,freq,columna,params,tipo,error)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)
    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-tendencia-fin.csv"    
    return response

# Gráfica con el modelo de tendencia determinista 
@app.get("/Plot/tendencia/fin")
async def obtener_grafica(inicio: str, fin:str, freq:str, tipo:int , error: Union[float, None] = None, columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float] = Query(...,description="Parametros de la tendencia")):
    """
    Devuelve una imagen con los datos graficados que siguen un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
    df = crear_df_fin_tend_det(inicio,fin,freq,columna,params,tipo,error)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de un modelo de tendencia determinista
@app.get("/reporte/tendencia/periodos")
def obtener_reporte(inicio: str, periodos: int, freq:str, tipo:int , error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float] = Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un reporte estadístico del modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
    
    if tipo == 1:
        subtipo = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params[0]) + ", b = " +str (params[1]) +" y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"
    
    elif tipo ==2:
        subtipo ="polinómica de grado "+ str(len(params)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params[0]) + ", b[1] = " + str (params[1])
        for k in range (2,len(params)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"
    
    elif tipo == 3: 
        subtipo ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params[0]) + ", b = " + str(params[1]) + " y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"
    
    elif tipo == 4:
        subtipo = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params[0]) + ", b = " + str(params[1]) + " y e0 es un random con valores entre [- " + str(error)+ " , "+ str(error) +" ]"

    tipos = "Modelo de tendencia determinista con tendencia " + subtipo
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de de periodos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(error)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros de la tendencia, a = params[0] y b[k] = params[k] --> "+str(params [0])
    for k in range (1, len (params)):
        explicacion = explicacion+", " + str(params [k])
    return {"Tipo": tipos, "Serie" : tendencia, "Parámetros" : explicacion }

# Creación del csv con los datos de una serie temporal con tendencia determinista
@app.get("/Datos/tendencia/periodos")
async def obtener_datos(inicio: str, periodos:int, freq:str, tipo:int , error: Union[float, None] = None,  columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un csv con los datos generados con un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
    df=crear_df_periodos_tend_det(inicio,periodos,freq,columna,params,tipo,error)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-tendencia-periodos.csv"
    
    return response

# Gráfica de una serie temporal de tendencia determinista
@app.get("/Plot/tendencia/periodos")   
async def obtener_grafica(inicio: str, periodos:int, freq:str, tipo:int , error: Union[float, None] = None,  columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve una imagen con los datos graficados que siguen un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**: lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **error**: coeficiente de error que se usa para generar los datos.
    - **columna**: nombre de la columna con los datos generados.
    - **params**: parámetros de la tendencia.
    """
    df = crear_df_periodos_tend_det(inicio,periodos,freq,columna,params,tipo,error)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse( buffer,media_type="image/png")


# reporte estadístico de un modelo que sigue cierta distribución
@app.get("/reporte/distribucion/fin")
def obtener_reporte(inicio: str, fin: str, freq:str, distr:int , columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un reporte estadístico de cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """

    if distr == 1 :
        subtipo = "normal"
        parametros ="Modelo con media = params[0] y desviación típica = params[1]. La media es " + str(params[0])+ " y la desviación típica es " + str(params[1])
        mean = params[0]
        var = params[1] **2
        
    elif distr ==2 :
        subtipo = "binomial"
        parametros = "Modelo con n = params[0] y p = params[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params[0])+" y el valor de p es "+str(params[1])+ ". Adicionalmente, se puede añadir un desplazamiento params[2]: "
        if len(params)==2:
            parametros = parametros + "en este caso no hay desplazamiento"
        elif len(params) == 3:
            parametros = parametros + "en este caso el desplazamiento es de " + str(params[2])
        mean, var = binom.stats(float(params[0]),float(params[1]), moments='mv')
        if len (params) == 3 :
           mean = mean + params[2]
           
    elif distr == 3 :
        subtipo = "poisson"
        parametros = "Modelo con mu = params[0] donde mu = parámetro de poisson. El valor de mu es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var= poisson.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
           
    elif distr == 4 :
        subtipo = "geométrica"
        parametros = "Modelo con p = params[0] donde p = probabilidad de éxito. El valor de p es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var = geom.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
            
    elif distr == 5:
        subtipo = "hipergeométrica"
        parametros = "Modelo con M = params[0], n = params[1] y N = params[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params[0])+", el valor de n es " + str(params[1])+" y el valor de N es " + str(params[2])+". Adicionalmente, se puede añadir un desplazamiento params[3] : "
        if len(params)==3:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 4:
            parametros += "en este caso el desplazamiento es de " + str(params[3])
        mean, var= hypergeom.stats(params[0], params[1],params[2], moments='mv')
        if len (params) == 4 :
           mean += params[3]
            
    elif distr == 6: 
        subtipo ="constante"
        parametros = "Modelo constante con constante = " + str(params[0])
        mean = params[0]
        var = 0
        
    elif distr == 7:
        subtipo = "uniforme"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl = desplazamiento de la distribución uniforme y obtenemos una distribucion uniforme [despl,despl+escala],"
        if len(params)==0:
            parametros += " en este caso no hay desplazamiento ni escala "
        elif len(params) == 1:
            parametros += " en este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= uniform.stats( moments='mv')
        if len (params) == 1 :
           mean = mean + params[0]
        elif len (params) == 2:
            mean = mean* params[1]
            mean += params[0]
            var = params[1]**2/12
            
    elif distr == 8:
        subtipo = "lognormal"
        parametros = "Modelo con s = params[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params)==1:
            parametros += " en este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += " en este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= lognorm.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = lognorm.mean(params[0], loc=params[1])
            var = lognorm.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = lognorm.mean(params[0], loc=params[1],scale=params[2])
            var = lognorm.var(params[0], loc=params[1], scale=params[2])
            
    elif distr == 9: 
        subtipo = "exponencial"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params)==0:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 1:
            parametros += "En este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= expon.stats( moments='mv')
        if len (params) == 1 :
            mean = expon.mean(loc=params[0])
        elif len (params) == 2:
            mean = expon.mean(loc=params[0],scale=params[1])
            var = expon.var(scale=params[1])
            
    elif distr == 10: 
        subtipo = "gamma"
        parametros = "Modelo con a = params[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= gamma.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = gamma.mean(params[0], loc=params[1])
            var = gamma.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = gamma.mean(params[0], loc=params[1],scale=params[2])
            var = gamma.var(params[0], scale=params[2])
            
    elif distr == 11: 
        subtipo = "beta"
        parametros = "Modelo con a = params[0] y b = params[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params[0])+ " y el de b es "+ str(params[1])+ ". Además, posee los parametros opcionales: despl = params[0] y escala = params[1], donde despl = desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params)==2:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[2])
        elif len(params) == 4:
            parametros += "En este caso el desplazamiento es de " + str(params[2]) +" y la escala de "+str(params[3])
        mean, var= beta.stats(params[0],params[1], moments='mv')
        if len (params) == 3:
            mean = beta.mean(params[0],params[1], loc=params[2])
            var = beta.var(params[0],params[1], loc = params[2])
        elif len (params) == 4:
            mean = beta.mean(params[0],params[1], loc=params[2],scale=params[3])
            var = beta.var(params[0],params[1], loc=params[2], scale=params[3])
            
    elif distr == 12: 
        subtipo = "chi cuadrado"
        parametros = "Modelo con df = params[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params[0]) +". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])

        mean, var= chi2.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = chi2.mean(params[0], loc=params[1])
            var = chi2.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = chi2.mean(params[0], loc=params[1],scale=params[2])
            var = chi2.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 13: 
        subtipo = "t-student"
        parametros = "Modelo con v = params[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= t.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = t.mean(params[0], loc=params[1])
            var = t.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = t.mean(params[0], loc=params[1],scale=params[2])
            var = t.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 14: 
        subtipo = "pareto"
        parametros = "Modelo con b = params[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= pareto.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = pareto.mean(params[0], loc=params[1])
            var = pareto.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = pareto.mean(params[0], loc=params[1],scale=params[2])
            var = pareto.var(params[0], loc=params[1],scale=params[2])
        
    elif distr == 15:
        subtipo = "linealmente decreciente"
        parametros = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
            
    elif distr == 16:
        subtipo = "linealmente creciente"
        parametros = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
    
    elif distr == 17:
        subtipo = "random"
        parametros = "Modelo con una distribución con valores aleatorios entre params[0] = " + str(params[0]) +" y params[1] = " + str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"

    if distr !=15 and distr!= 16 and distr!=17:
        mean = float(mean)
        var = float (var)
        
    tipos = "Modelo con una distribución " + subtipo
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Distr: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> " + str(distr)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    if len(params) > 0:
        explicacion = explicacion + ". Params: parámetros de la distribución --> "+str(params[0])
        for k in range (1, len (params)):
            explicacion = explicacion+", " + str(params[k])
    return {"Tipo": tipos,"Parametros de la distribución": parametros, "Parámetros de la query" : explicacion, "Media" :mean, "Varianza" : var}

# Creación de csv a partir de los datos de una distribución
@app.get("/Datos/distribucion/fin")
async def obtener_datos(inicio: str, fin:str, freq:str, distr:int , columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un csv con los datos que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_datos(inicio,fin,freq,columna,distr,params)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-distribucion-fin.csv"
    
    return response

# Gráfica de los datos siguiendo una distribución
@app.get("/Plot/distribucion/fin")
async def obtener_grafica(inicio: str, fin:str, freq:str, distr:int , columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve una imagen con los datos graficados que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_datos(inicio,fin,freq,columna,distr,params)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de los datos siguiendo cierta distribución
@app.get("/reporte/distribucion/periodos")
def obtener_reporte(inicio: str, periodos: int, freq:str, distr:int , columna: List[str]= Query(...,description="Nombres de las columnas"), params: List[float] = Query(...,description="Parametros de la distribución")):
    """
    Devuelve un reporte estadístico sobre cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """    
    if distr == 1 :
        subtipo = "normal"
        parametros ="Modelo con media = params[0] y desviación típica = params[1]. La media es " + str(params[0])+ " y la desviación típica es " + str(params[1])
        mean = params[0]
        var = params[1] **2
        
    elif distr ==2 :
        subtipo = "binomial"
        parametros = "Modelo con n = params[0] y p = params[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params[0])+" y el valor de p es "+str(params[1])+ ". Adicionalmente, se puede añadir un desplazamiento params[2]: "
        if len(params)==2:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 3:
            parametros += "en este caso el desplazamiento es de " + str(params[2])
        mean, var = binom.stats(params[0], params[1], moments='mv')
        if len (params) == 3 :
           mean += params[2]
           
    elif distr== 3 :
        subtipo = "poisson"
        parametros = "Modelo con mu = params[0] donde mu = parámetro de poisson. El valor de mu es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var= poisson.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
           
    elif distr == 4 :
        subtipo = "geométrica"
        parametros = "Modelo con p = params[0] donde p = probabilidad de éxito. El valor de p es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var = geom.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
            
    elif distr == 5:
        subtipo = "hipergeométrica"
        parametros = "Modelo con M = params[0], n = params[1] y N = params[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params[0])+", el valor de n es " + str(params[1])+" y el valor de N es " + str(params[2])+". Adicionalmente, se puede añadir un desplazamiento params[3] : "
        if len(params)==3:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 4:
            parametros += "en este caso el desplazamiento es de " + str(params[3])
        mean, var= hypergeom.stats(params[0], params[1],params[2], moments='mv')
        if len (params) == 4 :
           mean += params[3]
            
    elif distr == 6: 
        subtipo ="constante"
        parametros = "Modelo constante con constante = " + str(params[0])
        mean = params[0]
        var = 0
        
    elif distr == 7:
        subtipo = "uniforme"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución uniforme y obtenemos una distribucion uniforme [despl,despl+escala],"
        if len(params)==0:
            parametros += " en este caso no hay desplazamiento ni escala "
        elif len(params) == 1:
            parametros += " en este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= uniform.stats( moments='mv')
        if len (params) == 1 :
           mean = mean + params[0]
        elif len (params) == 2:
            mean = mean* params[1]
            mean += params[0]
            var = params[1]**2/12
            
    elif distr == 8:
        subtipo = "lognormal"
        parametros = "Modelo con s = params[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params)==1:
            parametros += " en este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += " en este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= lognorm.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = lognorm.mean(params[0], loc=params[1])
            var = lognorm.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = lognorm.mean(params[0], loc=params[1],scale=params[2])
            var = lognorm.var(params[0], loc=params[1], scale=params[2])
            
    elif distr == 9: 
        subtipo = "exponencial"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params)==0:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 1:
            parametros += "En este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= expon.stats( moments='mv')
        if len (params) == 1 :
            mean = expon.mean(loc=params[0])
        elif len (params) == 2:
            mean = expon.mean(loc=params[0],scale=params[1])
            var = expon.var(scale=params[1])
            
    elif distr == 10: 
        subtipo = "gamma"
        parametros = "Modelo con a = params[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= gamma.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = gamma.mean(params[0], loc=params[1])
            var = gamma.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = gamma.mean(params[0], loc=params[1],scale=params[2])
            var = gamma.var(params[0], scale=params[2])
            
    elif distr == 11: 
        subtipo = "beta"
        parametros = "Modelo con a = params[0] y b = params[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params[0])+ " y el de b es "+ str(params[1])+ ". Además, posee los parametros opcionales: despl = params[0] y escala = params[1], donde despl = desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params)==2:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[2])
        elif len(params) == 4:
            parametros += "En este caso el desplazamiento es de " + str(params[2]) +" y la escala de "+str(params[3])
        mean, var= beta.stats(params[0],params[1], moments='mv')
        if len (params) == 3:
            mean = beta.mean(params[0],params[1], loc=params[2])
            var = beta.var(params[0],params[1], loc = params[2])
        elif len (params) == 4:
            mean = beta.mean(params[0],params[1], loc=params[2],scale=params[3])
            var = beta.var(params[0],params[1], loc=params[2], scale=params[3])
            
    elif distr == 12: 
        subtipo = "chi cuadrado"
        parametros = "Modelo con df = params[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params[0]) +". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])

        mean, var= chi2.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = chi2.mean(params[0], loc=params[1])
            var = chi2.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = chi2.mean(params[0], loc=params[1],scale=params[2])
            var = chi2.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 13: 
        subtipo = "t-student"
        parametros = "Modelo con v = params[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= t.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = t.mean(params[0], loc=params[1])
            var = t.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = t.mean(params[0], loc=params[1],scale=params[2])
            var = t.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 14: 
        subtipo = "pareto"
        parametros = "Modelo con b = params[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= pareto.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = pareto.mean(params[0], loc=params[1])
            var = pareto.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = pareto.mean(params[0], loc=params[1],scale=params[2])
            var = pareto.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 15:
        subtipo = "linealmente decreciente"
        parametros = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
            
    elif distr == 16:
        subtipo = "linealmente creciente"
        parametros = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
    
    elif distr == 17:
        subtipo = "random"
        parametros = "Modelo con una distribución con valores aleatorios entre params[0] = " + str(params[0]) +" y params[1] = " + str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
        
    if distr !=15 and distr!= 16 and distr!=17:
        mean = float(mean)
        var = float (var)
        
    tipos = "Modelo con una distribución " + subtipo
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de de periodos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Distr: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado (12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> " + str(distr)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    if len(params) > 0:
        explicacion = explicacion + ". Params: parámetros de la distribución --> "+str(params [0])
        for k in range (1, len (params)):
            explicacion = explicacion+", " + str(params [k])
    return {"Tipo": tipos,"Parametros de la distribución": parametros, "Parámetros de la query" : explicacion, "Media" :mean, "Varianza" : var}

# Creación csv con los datos siguiendo una distribución
@app.get("/Datos/distribucion/periodos")
async def obtener_datos(inicio: str, periodos:int, freq:str, distr:int,  columna: List[str]= Query(...,description="Nombres de las columnas"),params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un csv con los datos generados según cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """    
    df = crear_df_periodos_datos(inicio,periodos,freq,columna,distr,params)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-distribucion-periodos.csv"
    
    return response

# Gráfica con los datos siguiendo cierta distribución
@app.get("/Plot/distribucion/periodos")
async def obtener_grafica(inicio: str, periodos:int, freq:str, distr:int,  columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve una imagen con los datos graficados que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """    
    df = crear_df_periodos_datos(inicio,periodos,freq,columna,distr,params)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# MODELOS PERIÓDICOS

# reporte estadístico de datos periódicos según ciertas distribuciones
@app.get("/reporte/periodicos/fin")
async def obtener_reporte(inicio: str, fin:str, freq:str, distr:int, p: int, tipo:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un reporte estadístico sobre los datos periódicos que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo==1:
        periodicidad = "periodos de amplitud " + str(p)
    elif tipo==2 :
        periodicidad = str(p)+ " periodos"
        
    if distr == 1 :
        subtipo = "normal"
        parametros ="Modelo con media = params[0] y desviación típica = params[1]. La media es " + str(params[0])+ " y la desviación típica es " + str(params[1])
        mean = params[0]
        var = params[1] **2
        
    elif distr ==2 :
        subtipo = "binomial"
        parametros = "Modelo con n = params[0] y p = params[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params[0])+" y el valor de p es "+str(params[1])+ ". Adicionalmente, se puede añadir un desplazamiento params[2]: "
        if len(params)==2:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 3:
            parametros += "en este caso el desplazamiento es de " + str(params[2])
        mean, var = binom.stats(params[0], params[1], moments='mv')
        if len (params) == 3 :
           mean += params[2]
           
    elif distr== 3 :
        subtipo = "poisson"
        parametros = "Modelo con mu = params[0] donde mu = parámetro de poisson. El valor de mu es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var= poisson.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
           
    elif distr == 4 :
        subtipo = "geométrica"
        parametros = "Modelo con p = params[0] donde p = probabilidad de éxito. El valor de p es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var = geom.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
            
    elif distr == 5:
        subtipo = "hipergeométrica"
        parametros = "Modelo con M = params[0], n = params[1] y N = params[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params[0])+", el valor de n es " + str(params[1])+" y el valor de N es " + str(params[2])+". Adicionalmente, se puede añadir un desplazamiento params[3] : "
        if len(params)==3:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 4:
            parametros += "en este caso el desplazamiento es de " + str(params[3])
        mean, var= hypergeom.stats(params[0], params[1],params[2], moments='mv')
        if len (params) == 4 :
           mean += params[3]
            
    elif distr == 6: 
        subtipo ="constante"
        parametros = "Modelo constante con constante = " + str(params[0])
        mean = params[0]
        var = 0
        
    elif distr == 7:
        subtipo = "uniforme"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución uniforme y obtenemos una distribucion uniforme [despl,despl+escala],"
        if len(params)==0:
            parametros += " en este caso no hay desplazamiento ni escala "
        elif len(params) == 1:
            parametros += " en este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= uniform.stats( moments='mv')
        if len (params) == 1 :
           mean = mean + params[0]
        elif len (params) == 2:
            mean = mean* params[1]
            mean += params[0]
            var = params[1]**2/12
            
    elif distr == 8:
        subtipo = "lognormal"
        parametros = "Modelo con s = params[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params)==1:
            parametros += " en este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += " en este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= lognorm.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = lognorm.mean(params[0], loc=params[1])
            var = lognorm.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = lognorm.mean(params[0], loc=params[1],scale=params[2])
            var = lognorm.var(params[0], loc=params[1], scale=params[2])
            
    elif distr == 9: 
        subtipo = "exponencial"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params)==0:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 1:
            parametros += "En este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= expon.stats( moments='mv')
        if len (params) == 1 :
            mean = expon.mean(loc=params[0])
        elif len (params) == 2:
            mean = expon.mean(loc=params[0],scale=params[1])
            var = expon.var(scale=params[1])
            
    elif distr == 10: 
        subtipo = "gamma"
        parametros = "Modelo con a = params[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= gamma.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = gamma.mean(params[0], loc=params[1])
            var = gamma.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = gamma.mean(params[0], loc=params[1],scale=params[2])
            var = gamma.var(params[0], scale=params[2])
            
    elif distr == 11: 
        subtipo = "beta"
        parametros = "Modelo con a = params[0] y b = params[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params[0])+ " y el de b es "+ str(params[1])+ ". Además, posee los parametros opcionales: despl = params[0] y escala = params[1], donde despl = desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params)==2:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[2])
        elif len(params) == 4:
            parametros += "En este caso el desplazamiento es de " + str(params[2]) +" y la escala de "+str(params[3])
        mean, var= beta.stats(params[0],params[1], moments='mv')
        if len (params) == 3:
            mean = beta.mean(params[0],params[1], loc=params[2])
            var = beta.var(params[0],params[1], loc = params[2])
        elif len (params) == 4:
            mean = beta.mean(params[0],params[1], loc=params[2],scale=params[3])
            var = beta.var(params[0],params[1], loc=params[2], scale=params[3])
            
    elif distr == 12: 
        subtipo = "chi cuadrado"
        parametros = "Modelo con df = params[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params[0]) +". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])

        mean, var= chi2.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = chi2.mean(params[0], loc=params[1])
            var = chi2.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = chi2.mean(params[0], loc=params[1],scale=params[2])
            var = chi2.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 13: 
        subtipo = "t-student"
        parametros = "Modelo con v = params[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= t.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = t.mean(params[0], loc=params[1])
            var = t.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = t.mean(params[0], loc=params[1],scale=params[2])
            var = t.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 14: 
        subtipo = "pareto"
        parametros = "Modelo con b = params[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= pareto.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = pareto.mean(params[0], loc=params[1])
            var = pareto.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = pareto.mean(params[0], loc=params[1],scale=params[2])
            var = pareto.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 15:
        subtipo = "linealmente decreciente"
        parametros = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
            
    elif distr == 16:
        subtipo = "linealmente creciente"
        parametros = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
    
    elif distr == 17:
        subtipo = "random"
        parametros = "Modelo con una distribución con valores aleatorios entre params[0] = " + str(params[0]) +" y params[1] = " + str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
        
    if distr !=15 and distr!= 16 and distr!=17:
        mean = float(mean)
        var = float (var)
        
    tipos = "Modelo periodico siguiendo una distribución " + subtipo + " con " + periodicidad
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Distr: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> " + str(distr)
    explicacion += ". p: indica la amplitud del periodo (tipo 1) o la cantidad de periodos (tipo 2) --> " + str(p)
    explicacion += ". Tipo: por amplitud (1) / por cantidad (2) --> "+ str(tipo)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    if len(params)>0:
        explicacion = explicacion + ". Params: parámetros de la distribución --> "+str(params[0])
        for k in range (1, len (params)):
            explicacion = explicacion+", " + str(params[k])
    return {"Tipo": tipos,"Parametros de la distribución": parametros, "Parámetros de la query" : explicacion, "Media" :mean, "Varianza" : var}

# Creación csv de datos periódicos según cierta distribución
@app.get("/Datos/periodicos/fin")
async def obtener_datos(inicio: str, fin:str, freq:str, distr:int, p: int, tipo:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un csv con los datos periódicos que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df =crear_df_fin_periodicos(inicio,fin,freq,columna,distr,params,p,tipo)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-periodicos-fin.csv"
    
    return response

# Gráfica de datos periódicos según cierta distribución
@app.get("/Plot/periodicos/fin")
async def obtener_grafica(inicio: str, fin:str, freq:str, distr:int, p: int, tipo:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve una imagen con los datos periódicos graficados que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_periodicos(inicio,fin,freq,columna,distr,params, p,tipo)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de datos periódicos según ciertas distribuciones 
@app.get("/reporte/periodicos/periodos")
async def obtener_reporte(inicio: str, periodos:int, freq:str, distr:int, p: int, tipo:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un reporte estadístico sobre los datos periódicos que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar .
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo==1:
        periodicidad = "periodos de amplitud " + str(p)
    elif tipo==2 :
        periodicidad = str(p)+ " periodos"
        
    if distr == 1 :
        subtipo = "normal"
        parametros ="Modelo con media = params[0] y desviación típica = params[1]. La media es " + str(params[0])+ " y la desviación típica es " + str(params[1])
        mean = params[0]
        var = params[1] **2
    elif distr ==2 :
        subtipo = "binomial"
        parametros = "Modelo con n = params[0] y p = params[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params[0])+" y el valor de p es "+str(params[1])+ ". Adicionalmente, se puede añadir un desplazamiento params[2]: "
        if len(params)==2:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 3:
            parametros += "en este caso el desplazamiento es de " + str(params[2])
        mean, var = binom.stats(params[0], params[1], moments='mv')
        if len (params) == 3 :
           mean += params[2]
    elif distr== 3 :
        subtipo = "poisson"
        parametros = "Modelo con mu = params[0] donde mu = parámetro de poisson. El valor de mu es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var= poisson.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
           
    elif distr == 4 :
        subtipo = "geométrica"
        parametros = "Modelo con p = params[0] donde p = probabilidad de éxito. El valor de p es " + str(params[0])+". Adicionalmente, se puede añadir un desplazamiento params[1] : "
        if len(params)==1:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 2:
            parametros += "en este caso el desplazamiento es de " + str(params[1])
        mean, var = geom.stats(params[0], moments='mv')
        if len (params) == 2 :
           mean += params[1]
            
    elif distr == 5:
        subtipo = "hipergeométrica"
        parametros = "Modelo con M = params[0], n = params[1] y N = params[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params[0])+", el valor de n es " + str(params[1])+" y el valor de N es " + str(params[2])+". Adicionalmente, se puede añadir un desplazamiento params[3] : "
        if len(params)==3:
            parametros += "en este caso no hay desplazamiento"
        elif len(params) == 4:
            parametros += "en este caso el desplazamiento es de " + str(params[3])
        mean, var= hypergeom.stats(params[0], params[1],params[2], moments='mv')
        if len (params) == 4 :
           mean += params[3]
            
    elif distr == 6: 
        subtipo ="constante"
        parametros = "Modelo constante con constante = " + str(params[0])
        mean = params[0]
        var = 0
        
    elif distr == 7:
        subtipo = "uniforme"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución uniforme y obtenemos una distribucion uniforme [despl,despl+escala],"
        if len(params)==0:
            parametros += " en este caso no hay desplazamiento ni escala"
        elif len(params) == 1:
            parametros += " en este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= uniform.stats( moments='mv')
        if len (params) == 1 :
           mean = mean + params[0]
        elif len (params) == 2:
            mean = mean* params[1]
            mean += params[0]
            var = params[1]**2/12
            
    elif distr == 8:
        subtipo = "lognormal"
        parametros = "Modelo con s = params[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params)==1:
            parametros += " en este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += " en este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += " en este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= lognorm.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = lognorm.mean(params[0], loc=params[1])
            var = lognorm.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = lognorm.mean(params[0], loc=params[1],scale=params[2])
            var = lognorm.var(params[0], loc=params[1], scale=params[2])
            
    elif distr == 9: 
        subtipo = "exponencial"
        parametros = "Modelo con parametros opcionales: despl = params[0] y escala = params[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params)==0:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 1:
            parametros += "En este caso el desplazamiento es de " + str(params[0])
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[0]) +" y la escala de "+str(params[1])
        mean, var= expon.stats( moments='mv')
        if len (params) == 1 :
            mean = expon.mean(loc=params[0])
        elif len (params) == 2:
            mean = expon.mean(loc=params[0],scale=params[1])
            var = expon.var(scale=params[1])
            
    elif distr == 10: 
        subtipo = "gamma"
        parametros = "Modelo con a = params[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= gamma.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = gamma.mean(params[0], loc=params[1])
            var = gamma.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = gamma.mean(params[0], loc=params[1],scale=params[2])
            var = gamma.var(params[0], scale=params[2])
            
    elif distr == 11: 
        subtipo = "beta"
        parametros = "Modelo con a = params[0] y b = params[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params[0])+ " y el de b es "+ str(params[1])+ ". Además, posee los parametros opcionales: despl = params[0] y escala = params[1], donde despl = desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params)==2:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[2])
        elif len(params) == 4:
            parametros += "En este caso el desplazamiento es de " + str(params[2]) +" y la escala de "+str(params[3])
        mean, var= beta.stats(params[0],params[1], moments='mv')
        if len (params) == 3:
            mean = beta.mean(params[0],params[1], loc=params[2])
            var = beta.var(params[0],params[1], loc = params[2])
        elif len (params) == 4:
            mean = beta.mean(params[0],params[1], loc=params[2],scale=params[3])
            var = beta.var(params[0],params[1], loc=params[2], scale=params[3])
            
    elif distr == 12: 
        subtipo = "chi cuadrado"
        parametros = "Modelo con df = params[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params[0]) +". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])

        mean, var= chi2.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = chi2.mean(params[0], loc=params[1])
            var = chi2.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = chi2.mean(params[0], loc=params[1],scale=params[2])
            var = chi2.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 13: 
        subtipo = "t-student"
        parametros = "Modelo con v = params[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= t.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = t.mean(params[0], loc=params[1])
            var = t.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = t.mean(params[0], loc=params[1],scale=params[2])
            var = t.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 14: 
        subtipo = "pareto"
        parametros = "Modelo con b = params[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params[0])+ ". Además, posee los parametros opcionales: despl = params[1] y escala = params[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params)==1:
            parametros += "En este caso no hay desplazamiento ni escala"
        elif len(params) == 2:
            parametros += "En este caso el desplazamiento es de " + str(params[1])
        elif len(params) == 3:
            parametros += "En este caso el desplazamiento es de " + str(params[1]) +" y la escala de "+str(params[2])
        mean, var= pareto.stats(params[0], moments='mv')
        if len (params) == 2:
            mean = pareto.mean(params[0], loc=params[1])
            var = pareto.var(params[0], loc = params[1])
        elif len (params) == 3:
            mean = pareto.mean(params[0], loc=params[1],scale=params[2])
            var = pareto.var(params[0], loc=params[1],scale=params[2])
            
    elif distr == 15:
        subtipo = "linealmente decreciente"
        parametros = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
            
    elif distr == 16:
        subtipo = "linealmente creciente"
        parametros = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params[0] = "+ str(params[0])+" y b = params[1] = "+ str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
    
    elif distr == 17:
        subtipo = "random"
        parametros = "Modelo con una distribución con valores aleatorios entre params[0] = " + str(params[0]) +" y params[1] = " + str(params[1])
        mean = "Información no relevante"
        var = "Información no relevante"
        
    if distr !=15 and distr!= 16 and distr!=17:
        mean = float(mean)
        var = float (var)
        
    tipos = "Modelo periodico siguiendo una distribución " + subtipo + " con " + periodicidad
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Distr: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto (14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> " + str(distr)
    explicacion += ". p: indica la amplitud del periodo (tipo 1) o la cantidad de periodos (tipo 2) --> " + str(p)
    explicacion += ". Tipo: por amplitud (1) / por cantidad (2) --> "+ str(tipo)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    if len (params)>0:
        explicacion = explicacion + ". Params: parámetros de la distribución --> "+str(params [0])
        for k in range (1, len (params)):
            explicacion = explicacion+", " + str(params[k])
    return {"Tipo": tipos,"Parametros de la distribución": parametros, "Parámetros de la query" : explicacion, "Media" :mean, "Varianza" : var}

# Creación de csv con datos periódicos según ciertas distribuciones
@app.get("/Datos/periodicos/periodos")
async def obtener_datos(inicio: str, periodos:int, freq:str, distr:int, p:int, tipo:int,  columna: List[str]= Query(...,description="Nombres de las columnas"), params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve un csv con los datos periódicos que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df= crear_df_periodos_periodicos(inicio,periodos,freq,columna,distr,params,p,tipo)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-periodicos-periodos.csv"
    
    return response
 
# Gráfica de datos periódicos según ciertas distribuciones 
@app.get("/Plot/periodicos/periodos")
async def obtener_grafica(inicio: str, periodos:int, freq:str, distr:int, p:int, tipo:int,  columna: List[str]= Query(...,description="Nombres de las columnas"),params: Optional[List[float]]= Query([],description="Parametros de la distribución")):
    """
    Devuelve una imagen con los datos periódicos graficados que siguen cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **Distr, params** : Indica la distribución a seguir y los parámetros de esta distribución. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p**: indica la cantidad de periodos (tipo=2) / la amplitud de los periodos (tipo=1)
    - **tipo**: valores posibles
        1. p = amplitud de periodo
        2. p = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_periodos_periodicos(inicio,periodos,freq,columna,distr,params,p,tipo)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")


# reporte estadístico de modelo ARMA
@app.get("/reporte/ARMA/fin")
async def obtener_reporte(inicio: str, fin:str, freq:str,c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un reporte estadístico sobre el modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """
     
    if phi == []:
        subtipo = "de medias móviles"
        parametros= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros = parametros  + ", teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo = "autorregresivo"
        parametros= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros = parametros  + ", phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo ="autorregresivo y de medias móviles"
        parametros = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros = parametros  + ", phi_"+ str(k)+" = " + str (phi[k])
        parametros = parametros + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros = parametros  + ", teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo += " estacional con amplitud de la estación: " + str(s)
    tipos = "Modelo " + subtipo
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". c: constante del modelo --> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación --> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco --> " + str(desv)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    return {"Tipo": tipos, "Parámetro del modelo" : parametros, "Parámetros de la query" : explicacion }

#  Creación csv con los datos del modelo ARMA
@app.get("/Datos/ARMA/fin")
async def obtener_datos(inicio: str, fin:str, freq:str,c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un csv con los datos que siguen un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """  
    df = crear_df_fin_ARMA(inicio,fin,freq,columna,c,desv,s,phi,teta)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-ARMA-fin.csv"
    
    return response

# Gráfica con los datos del modelo ARMA
@app.get("/Plot/ARMA/fin")
async def obtener_grafica(inicio: str, fin:str, freq:str, c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve una imagen con los datos graficados que siguen un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """  
    df = crear_df_fin_ARMA(inicio,fin,freq,columna,c,desv,s,phi,teta)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico del modelo ARMA
@app.get("/reporte/ARMA/periodos")
async def obtener_reporte(inicio: str, periodos:int, freq:str,c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un reporte estadístico de los datos que siguen un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo = "de medias móviles"
        parametros= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros = parametros  + ", teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo = "autorregresivo"
        parametros= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros = parametros  + ", phi_"+ str(k)+" = " + str (phi[k])
           
    else: 
        subtipo ="autorregresivo y de medias móviles"
        parametros = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros = parametros  + ", phi_"+ str(k)+" = " + str (phi[k])
        parametros = parametros + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros = parametros  + ", teta_"+ str(k)+" = " + str (teta[k])
           
    if s != 0:
        subtipo += " estacional con amplitud de la estación: " + str(s)
        
    tipos = "Modelo " + subtipo
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar  --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". c: constante del modelo --> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación --> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco --> " + str(desv)
    explicacion = explicacion + ". Columna: nombre de la columna --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    return {"Tipo": tipos, "Parámetro del modelo" : parametros, "Parámetros de la query" : explicacion }

# Creación csv con datos del modelo ARMA 
@app.get("/Datos/ARMA/periodos")
async def obtener_datos(inicio: str, periodos:int, freq:str,c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un csv con los datos generados que siguen un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_ARMA(inicio,periodos,freq,columna,c,desv,s,phi,teta)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-ARMA-periodos.csv"
    
    return response
 
# Gráfica con datos del modelo ARMA
@app.get("/Plot/ARMA/periodos") 
async def obtener_grafica(inicio: str, periodos:int, freq:str,c:float, desv:float, s : Union[int, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve una imagen con los datos graficados que siguen un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación)
    - **desv**: desviación típica del ruido blanco
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_ARMA(inicio,periodos,freq,columna,c,desv,s,phi,teta)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# MODELOS CON DRIFT
# reporte estadístico de modelo con drift que cambia de distribución
@app.get("/reporte/drift/fin/dist-dist")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):  
    """
    Devuelve un reporte estadísitico de los datos generados a partir de un drift cambiando de una fistribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
          
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego una segunda distribución "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1 y Dist2: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado (12), t-student(13), pareto (14), linealmente decreciente(15), linealmente creciente (16) y random (17) --> Dist1: " + str(dist1) +" y Dist2: "+ str(dist2) 
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": parametros2, "Parámetros de la query" : explicacion, "Media primera distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv con datos del drift de cambio de una distribución a otra 
@app.get("/Datos/drift/fin/dist-dist")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[dist2,params2],1,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-dist-fin.csv"
    
    return response

# Gráfica con datos del drift de cambio de una distribución a otra
@app.get("/Plot/drift/fin/dist-dist")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando de una distribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[dist2,params2],1,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# reporte estádistico del drift de cambio de una distribución a otra 
@app.get("/reporte/drift/periodos/dist-dist")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la distribución")): 
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un drift cambiando de una distribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """   
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
           
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego una segunda distribución "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1 y Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado (12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: " + str(dist1) +" y Dist2: "+ str(dist2) 
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": parametros2, "Parámetros de la query" : explicacion, "Media primer distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv del drift de cambio de una distribución a otra 
@app.get("/Datos/drift/periodos/dist-dist")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int,dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[dist2,params2],1,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-dist-periodos.csv"
    
    return response

# Gráfica del drift de cambio de una distribución a otra 
@app.get("/Plot/drift/periodos/dist-dist")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int,dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando de una distribución a otra. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **columna**: nombre de la columna con los datos generados.
    """   
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna, [dist1,params1],[dist2,params2],1,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico del drift de cambio de una distribución a un modelo ARMA
@app.get("/reporte/drift/fin/dist-ARMA")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, c:float, desv:float, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un reporte estadístico de los datos generados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """      
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución,"
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
     
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1) 
        
    if phi == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros2 = parametros2  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros2 = parametros2  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros2 = parametros2  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros2 = parametros2 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros2 = parametros2  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s)
    
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: " + str(dist1) 
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". c: constante del modelo 2--> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 2--> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 2 --> " + str(desv)
    explicacion = explicacion + ". Params: parámetros del modelo 2, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros del segundo modelo": parametros2, "Parámetros de la query" : explicacion, "Media primer distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv con datos de cambio de una distribución a modelo ARMA
@app.get("/Datos/drift/fin/dist-ARMA")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, c:float, desv:float, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[c,desv,s,phi,teta,[]],2,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-ARMA-fin.csv"
    
    return response

# Gráfica con datos de cambio de una distribución a modelo ARMA
@app.get("/Plot/drift/fin/dist-ARMA")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, c:float, desv:float, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve una imagen de los datos graficados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[c,desv,s,phi,teta,[]],2,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de datos de cambio de una distribución a modelo ARMA
@app.get("/reporte/drift/periodos/dist-ARMA")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, c:float ,desv:float ,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un reporte estadístico de los datos graficados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len (params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] = " + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if phi == []:
        subtipo2 = "de medias móviles"
        parametros2 = "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros2 = parametros2  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros2 = parametros2  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros2 = parametros2  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros2 = parametros2 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros2 = parametros2  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s)
    
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> " + str(dist1)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". c: constante del modelo 2--> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 2--> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 2 --> " + str(desv)
    explicacion = explicacion + ". Params: parámetros del modelo 2, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros del segundo modelo": parametros2, "Parámetros de la query" : explicacion, "Media primer distribución" :mean1, "Varianza de la primera distribución" :var1}

# Creación csv con datos de cambio de una distribución a modelo ARMA
@app.get("/Datos/drift/periodos/dist-ARMA")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, c:float ,desv:float ,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve un csv de los datos generados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[c,desv,s,phi,teta,[]],2,num_drift)

    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-ARMA-periodos.csv"
    
    return response  

# Gráfica con datos de cambio de una distribución a modelo ARMA
@app.get("/Plot/drift/periodos/dist-ARMA")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, c:float ,desv:float ,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles")):
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando una distribución por un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **c, phi, teta**: parámetros del modelo autorregresivo y de medias móviles que sigue la segunda parte de los datos
    - **s**: estacionalidad, tamaño de una estación (número de datos que hay en cada estación), del modelo que sigue la segunda parte de los datos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[c,desv,s,phi,teta,[]],2,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico con drift del cambio de una distribución a un modelo periódico
@app.get("/reporte/drift/fin/dist-periodico")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """ 
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
        
    if tipo2==1:
        periodicidad = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"

    tipos2 = "modelo periódico siguiendo una distribución " + subtipo2 + " con " + periodicidad

    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1 y Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: " + str(dist1) +" y Dist2: "+ str(dist2) 
    explicacion += ". p: indica la amplitud del periodo (tipo2 1) o la cantidad de periodos (tipo2 2) --> " + str(p2)
    explicacion += ". tipo2: por amplitud (1) / por cantidad (2) --> "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": parametros2, "Parámetros de la query" : explicacion, "Media primer distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv drift del cambio de una distribución a un modelo periódico
@app.get("/Datos/drift/fin/dist-periodico")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[tipo2,dist2,params2,p2],3,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-periodico-fin.csv"
    
    return response  
    
# Gráfica drift del cambio de una distribución a un modelo periódico
@app.get("/Plot/drift/fin/dist-periodico")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna, [dist1,params1],[tipo2,dist2,params2,p2],3,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico con drift del cambio de una distribución a un modelo periódico
@app.get("/reporte/drift/periodos/dist-periodico")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2]: "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1]: "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl = desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if tipo2==1:
        periodicidad = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"

    tipos2 = "Modelo periódico siguiendo una distribución " + subtipo2 + " con " + periodicidad

    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1 y Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: " + str(dist1) +" y Dist2: "+ str(dist2) 
    explicacion += ". p2: indica la amplitud del periodo (tipo2 1) o la cantidad de periodos (tipo2 2) --> " + str(p2)
    explicacion += ". tipo2: por amplitud (1) / por cantidad (2) --> "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": parametros2, "Parámetros de la query" : explicacion, "Media primer distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv con drift del cambio de una distribución a un modelo periódico
@app.get("/Datos/drift/periodos/dist-periodico")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[tipo2,dist2,params2,p2],3,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-periodico-periodos.csv"
    
    return response  

# Gráfico con drift del cambio de una distribución a un modelo periódico
@app.get("/Plot/drift/periodos/dist-periodico")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, dist2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando de una distribución a un modelo periódico que sigue cierta distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos que posee la segunda distribución
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[tipo2,dist2,params2,p2],3,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico con drift del cambio de una distribución a un modelo de tendencia determinista
@app.get("/reporte/drift/fin/dist-tendencia")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error: Union[float,None] = 0 ,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un reporte estadísitico sobre los datos generados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista
    - **columna**: nombre de la columna con los datos generados.
    """
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante" 
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)

    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1)  
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": tendencia, "Parámetros de la query" : explicacion, "Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv drift del cambio de una distribución a un modelo de tendencia determinista    
@app.get("/Datos/drift/fin/dist-tendencia")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error: Union[float,None] = 0 ,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[params2,tipo2,coef_error],4,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)
    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-tendencia-fin.csv"
    
    return response  

# Gráfico drift del cambio de una distribución a un modelo de tendencia determinista
@app.get("/Plot/drift/fin/dist-tendencia")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error: Union[float,None] = 0 ,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve una imagen con un gráfico con los datos graficados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[dist1,params1],[params2,tipo2,coef_error],4,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico con drift del cambio de una distribución a un modelo de tendencia determinista
@app.get("/reporte/drift/periodos/dist-tendencia")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error: Union[float,None] = 0 ,columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] ** 2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
                
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
        
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
          
    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2  
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con una primera distribución " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1)  
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])
    return {"Tipo": tipos,"Parametros de la primera distribución": parametros1, "Parámetros de la segunda distribución": tendencia, "Parámetros de la query" : explicacion, "Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv con drift del cambio de una distribución a un modelo de tendencia determinista
@app.get("/Datos/drift/periodos/dist-tendencia")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error : Union[float,None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[params2,tipo2,coef_error],4,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-dist-tendencia-periodos.csv"
    
    return response 

# Gráfico con drift del cambio de una distribución a un modelo de tendencia determinista
@app.get("/Plot/drift/periodos/dist-tendencia")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, dist1:int, tipo2:int, coef_error : Union[float,None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la tendencia")):
    
    """
    Devuelve una imagen con los datos graficados a partir de un drift cambiando de una distribución a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato donde se produce el drift
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo.
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[dist1,params1],[params2,tipo2,coef_error],4,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por otro modelo ARMA
@app.get("/reporte/drift/fin/ARMA-ARMA")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int ,c1:float , desv1:float, c2:float, desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi1 == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c1)+" y con valores de teta1: teta1_0 " + str(teta1[0])
        for k in range (1,len(teta1)):
           parametros1 = parametros1  + ", teta1_"+ str(k)+" = " + str (teta1[k])    
    
    elif teta1 ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c1)+" y con valores de phi1: phi1_0 " + str(phi1[0])
        for k in range (1,len(phi1)):
           parametros1 = parametros1  + ", phi1_"+ str(k)+" = " + str (phi1[k])
    
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c1)+" y con valores de phi1: phi1_0 " + str(phi1[0])
        for k in range (1,len(phi1)):
           parametros1 = parametros1  + ", phi1_"+ str(k)+" = " + str (phi1[k])
        parametros1 = parametros1 + " y con valores de teta1: teta1_0 " + str(teta1[0])
        for k in range (1,len(teta1)):
           parametros1 = parametros1  + ", teta1_"+ str(k)+" = " + str (teta1[k])
    
    if s1 != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s1)
    
    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + ", teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + ", phi2_"+ str(k)+" = " + str (phi2[k])
    
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + ", phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + ", teta2_"+ str(k)+" = " + str (teta2[k])
    
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2)
    
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con un modelo " + subtipo1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c1, c2: constante del modelo 1 y 2--> c1: " + str(c1)+ " c2: "+ str(c2)
    explicacion = explicacion + ". s1, s2: amplitud de la estación del modelo 1 y 2--> s1: " + str(s1)+ " s2: "+ str(s2)
    explicacion = explicacion + ". Desv1, Desv2 : desviaciones típica del ruido blanco de ambos modelos --> desv1 :" + str(desv1) + " desv2: " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Parámetros del modelo 1: phi1 y teta1 -->"
    if phi1 != []:
        explicacion+= " phi1 : " + str(phi1[0])
        for k in range (1, len (phi1)):
            explicacion = explicacion+", " + str(phi1[k])
    if teta1!=[]:
        explicacion+= " teta1 : " + str(teta1[0])
        for k in range (1, len (teta1)):
            explicacion = explicacion+", " + str(teta1[k])
    explicacion = explicacion + ". Parámetros del modelo 2: phi2 y teta2 -->"
    if phi2 != []:
        explicacion+= " phi2 : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= " teta2 : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1, "Parámetro del modelo 2" : parametros2, "Parámetros de la query" : explicacion }
    
# Creación csv de drift de un modelo ARMA por otro modelo ARMA
@app.get("/Datos/drift/fin/ARMA-ARMA")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int ,c1:float , desv1:float, c2:float, desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c1,desv1,s1,phi1,teta1,[]],[c2,desv2,s2,phi2,teta2,[]],5,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-ARMA-fin.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por otro modelo ARMA
@app.get("/Plot/drift/fin/ARMA-ARMA")
async def obtener_gráfica(inicio: str, fin:str, freq:str, num_drift:int ,c1:float , desv1:float, c2:float, desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c1,desv1,s1,phi1,teta1,[]],[c2,desv2,s2,phi2,teta2,[]],5,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por otro modelo ARMA
@app.get("/reporte/drift/periodos/ARMA-ARMA")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int ,c1:float , desv1:float, c2:float, desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    
    if phi1 == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c1)+" y con valores de teta1: teta1_0 " + str(teta1[0])
        for k in range (1,len(teta1)):
           parametros1 = parametros1  + " teta1_"+ str(k)+" = " + str (teta1[k])
              
    elif teta1 ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c1)+" y con valores de phi1: phi1_0 " + str(phi1[0])
        for k in range (1,len(phi1)):
           parametros1 = parametros1  + " phi1_"+ str(k)+" = " + str (phi1[k])
           
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c1)+" y con valores de phi1: phi1_0 " + str(phi1[0])
        for k in range (1,len(phi1)):
           parametros1 = parametros1  + " phi1_"+ str(k)+" = " + str (phi1[k])
        parametros1 = parametros1 + " y con valores de teta1: teta1_0 " + str(teta1[0])
        for k in range (1,len(teta1)):
           parametros1 = parametros1  + " teta1_"+ str(k)+" = " + str (teta1[k])
           
    if s1 != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s1)
    
    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2)

    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " con un modelo " + subtipo1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar--> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c1, c2: constante del modelo 1 y 2--> c1: " + str(c1)+ " c2: "+ str(c2)
    explicacion = explicacion + ". s1, s2: amplitud de la estación del modelo 1 y 2--> s1: " + str(s1)+ " s2: "+ str(s2)
    explicacion = explicacion + ". Desv1, Desv2 : desviaciones típica del ruido blanco de ambos modelos --> desv1:" + str(desv1) + " desv2: " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Parámetros del modelo 1: phi1 y teta1 -->"
    if phi1 != []:
        explicacion+= " phi1 : " + str(phi1[0])
        for k in range (1, len (phi1)):
            explicacion = explicacion+", " + str(phi1[k])
    if teta1!=[]:
        explicacion+= " teta1 : " + str(teta1[0])
        for k in range (1, len (teta1)):
            explicacion = explicacion+", " + str(teta1[k])
    explicacion = explicacion + ". Parámetros del modelo 2: phi2 y teta2 --> "
    if phi2 != []:
        explicacion+= "phi2 : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= "teta2 : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1, "Parámetro del modelo 2" : parametros2, "Parámetros de la query" : explicacion }
    
# Creación csv de drift de un modelo ARMA por otro modelo ARMA
@app.get("/Datos/drift/periodos/ARMA-ARMA")
def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int ,c1:float , desv1:float, c2:float , desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c1,desv1,s1,phi1,teta1,[]],[c2,desv2,s2,phi2,teta2,[]],5,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-ARMA-periodos.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por otro modelo ARMA
@app.get("/Plot/drift/periodos/ARMA-ARMA")
async def obtener_gráfica(inicio: str, periodos:int, freq:str, num_drift:int ,c1:float , desv1:float, c2:float , desv2:float, s1: Union[int,None] = 0, s2: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi1: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta1:Optional[List[float]]= Query([],description="Parámetros medias móviles"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c1, phi1, teta1** : parámetros de los modelo autorregresivos y de medias móviles 1. c1 --> constante, phi1 --> parámetros del modelo autorregresivo y teta1 --> parámetros del modelo de medias móviles
    - **s1** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv1**: desviación típica del ruido blanco del modelo 1
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi2 --> parámetros del modelo autorregresivo y teta2 --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c1,desv1,s1,phi1,teta1,[]],[c2,desv2,s2,phi2,teta2,[]],5,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por una distribución
@app.get("/reporte/drift/fin/ARMA-dist")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, dist2:int,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
    
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2) 
         
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un modelo " + subtipo1 + " y luego una distribucion "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c: constante del modelo 1 --> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 1 --> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 1--> " + str(desv)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo ARMA por una distribución
@app.get("/Datos/drift/fin/ARMA-dist")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, dist2:int,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[dist2,params2],6,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-dist-fin.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por una distribución
@app.get("/Plot/drift/fin/ARMA-dist")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, dist2:int,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[dist2,params2],6,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por una distribución
@app.get("/reporte/drift/periodos/ARMA-dist")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, dist2:int,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
    
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala"
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
            
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un modelo " + subtipo1 + " y luego una distribucion "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c: constante del modelo 1--> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 1--> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 1--> " + str(desv)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo ARMA por una distribución
@app.get("/Datos/drift/periodos/ARMA-dist")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int ,c:float, desv:float, dist2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[dist2,params2],6,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-dist-periodos.csv"
    
    return response 

# Gráfica de drift de un modelo ARMA por una distribución
@app.get("/Plot/drift/periodos/ARMA-dist")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int ,c:float, desv:float, dist2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[dist2,params2],6,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por uno periódico
@app.get("/reporte/drift/fin/ARMA-periodico")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, c:float, desv:float, tipo2:int, dist2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
    
    if tipo2==1:
        periodicidad = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un modelo " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c: constante del modelo 1--> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 1--> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 1--> " + str(desv)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". p2: indica la amplitud del periodo (tipo2 1) o la cantidad de periodos (tipo2 2) --> " + str(p2)
    explicacion += ". tipo2: por amplitud (1) / por cantidad (2) --> "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo ARMA por uno periódico
@app.get("/Datos/drift/fin/ARMA-periodico")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, c:float, desv:float, tipo2:int, distr2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[tipo2,distr2,params2,p2],7,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-periodico-fin.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por uno periódico
@app.get("/Plot/drift/fin/ARMA-periodico")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, c:float, desv:float, tipo2:int, distr2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[tipo2,distr2,params2,p2],7,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por uno periódico
@app.get("/reporte/drift/periodos/ARMA-periodico")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, c:float, desv:float, tipo2:int, dist2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico de los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
    
    if tipo2==1:
        periodicidad = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"

    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean = float(mean)
        var = float (var)
        
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un modelo " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". c: constante del modelo 1--> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación del modelo 1--> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blanco del modelo 1--> " + str(desv)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". p2: indica la amplitud del periodo (tipo2 1) o la cantidad de periodos (tipo2 2) --> " + str(p2)
    explicacion += ". tipo2: por amplitud (1) / por cantidad (2) --> "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo ARMA por uno periódico
@app.get("/Datos/drift/periodos/ARMA-periodico")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, tipo2:int, distr2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[tipo2,distr2,params2,p2],7,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-periodico-periodos.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por uno periódico
@app.get("/Plot/drift/periodos/ARMA-periodico")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, tipo2:int, distr2:int, p2:int, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[tipo2,distr2,params2,p2],7,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por una tendencia
@app.get("/reporte/drift/fin/ARMA-tendencia")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
        
    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer modelo " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". c: constante del modelo --> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación --> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blaco --> " + str(desv)
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
            
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1, "Parámetro del modelo 2" : tendencia, "Parámetros de la query" : explicacion }

# Creación csv de drift de un modelo ARMA por una tendencia
@app.get("/Datos/drift/fin/ARMA-tendencia")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[params2,tipo2,coef_error],8,num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-tendencia-fin.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por una tendencia
@app.get("/Plot/drift/fin/ARMA-tendencia")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: List[float]= Query(...,description="Parametros de la tendencia determinista")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[c,desv,s,phi,teta,[]],[params2,tipo2,coef_error],8,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo ARMA por una tendencia
@app.get("/reporte/drift/periodos/ARMA-tendencia")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0,s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    if phi == []:
        subtipo1 = "de medias móviles"
        parametros1= "La serie sigue una distribución de medias móviles con constante c = "+ str(c)+" y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    elif teta ==[]:
        subtipo1 = "autorregresivo"
        parametros1= "La serie sigue una distribución autorregresiva con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
           
    else: 
        subtipo1 ="autorregresivo y de medias móviles"
        parametros1 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c = "+ str(c)+" y con valores de phi: phi_0 " + str(phi[0])
        for k in range (1,len(phi)):
           parametros1 = parametros1  + " phi_"+ str(k)+" = " + str (phi[k])
        parametros1 = parametros1 + " y con valores de teta: teta_0 " + str(teta[0])
        for k in range (1,len(teta)):
           parametros1 = parametros1  + " teta_"+ str(k)+" = " + str (teta[k])
           
    if s != 0:
        subtipo1 += " estacional con amplitud de la estación: " + str(s)
        
    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer modelo " + subtipo1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". c: constante del modelo --> " + str(c)
    explicacion = explicacion + ". s: amplitud de la estación --> " + str(s)
    explicacion = explicacion + ". Desv: desviación típica del ruido blaco --> " + str(desv)
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi != []:
        explicacion+= " phi : " + str(phi[0])
        for k in range (1, len (phi)):
            explicacion = explicacion+", " + str(phi[k])
    if teta!=[]:
        explicacion+= " teta : " + str(teta[0])
        for k in range (1, len (teta)):
            explicacion = explicacion+", " + str(teta[k])
            
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1, "Parámetro del modelo 2" : tendencia, "Parámetros de la query" : explicacion }

# Creación csv de drift de un modelo ARMA por una tendencia
@app.get("/Datos/drift/periodos/ARMA-tendencia")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: List[float]= Query(...,description="Parametros de la tendencia determinista")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[params2,tipo2,coef_error],8,num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-ARMA-tendencia-periodos.csv"
    
    return response 

# Gráfico de drift de un modelo ARMA por una tendencia
@app.get("/Plot/drift/periodos/ARMA-tendencia")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int ,c:float , desv:float, tipo2:int,coef_error: Union[float, None] = 0, s: Union[int,None] = 0, columna: List[str]= Query(description="Nombres de las columnas"), phi: Optional[List[float]]= Query([],description="Parámetros autorregresivos"), teta:Optional[List[float]]= Query([],description="Parámetros medias móviles"), params2: List[float]= Query(...,description="Parametros de la tendencia determinista")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo autorregresivo y de medias móviles a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **c, phi, teta** : parámetros de los modelo autorregresivos y de medias móviles 1. c --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 1
    - **desv**: desviación típica del ruido blanco del modelo 1
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[c,desv,s,phi,teta,[]],[params2,tipo2,coef_error],8,num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por otro periódico
@app.get("/reporte/drift/fin/periodico-periodico")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, tipo2:int, dist2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    
    if tipo2==1:
        periodicidad2 = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad2 = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2= float(mean2)
        var2 = float (var2)
        
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1, Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: "+ str(dist1) +" Dist2: "+ str(dist2) 
    explicacion += ". p1, p2: indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> p1: " + str(p1) +" p2: " + str(p2)
    explicacion += ". tipo1,tipo2: por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo1) +" tipo2: "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params2: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1[0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros del modelo 2: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo periódico por otro periódico
@app.get("/Datos/drift/fin/periodico-periodico")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int, distr2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[tipo2,distr2,params2,p2], 9, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-periodico-fin.csv"
    
    return response 

# Gráfico de drift de un modelo periódico por otro periódico
@app.get("/Plot/drift/fin/periodico-periodico")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int, distr2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen sobre los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[tipo2,distr2,params2,p2], 9, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por otro periódico
@app.get("/reporte/drift/periodos/periodico-periodico")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, tipo2:int, dist2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """   
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if tipo2==1:
        periodicidad2 = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad2 = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1, Dist2: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random (17) --> Dist1: "+ str(dist1) +" Dist2: "+ str(dist2) 
    explicacion += ". p1, p2: indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> p1: " + str(p1) +" p2: " + str(p2)
    explicacion += ". tipo1,tipo2: por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo1) +" tipo2: "+ str(tipo2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params2: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1[0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros del modelo 2: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo periódico por otro periódico
@app.get("/Datos/drift/periodos/periodico-periodico")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int, distr2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen sobre los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[tipo2,distr2,params2,p2], 9, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-periodico-periodos.csv"
    
    return response 

# Gráfico de drift de un modelo periódico por otro periódico
@app.get("/Plot/drift/periodos/periodico-periodico")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int, distr2:int, p2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen de los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[tipo2,distr2,params2,p2], 9, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por una distribución
@app.get("/reporte/drift/fin/periodico-distr")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson. El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego una distribucion "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1, Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: "+ str(dist1) +" Dist2: "+ str(dist2) 
    explicacion += ". p1 : indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> p1: " + str(p1) 
    explicacion += ". tipo1 : por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo1)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params2: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1[0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo periódico por una distribución
@app.get("/Datos/drift/fin/periodico-distr")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, distr2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con  los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[distr2,params2], 10, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-dist-fin.csv"
    
    return response 

# Gráfico de drift de un modelo periódico por una distribución
@app.get("/Plot/drift/fin/periodico-distr")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, distr2:int, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[distr2,params2], 10, num_drift)

    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por una distribución
@app.get("/reporte/drift/periodos/periodico-distr")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, dist2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
               
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego una distribucion "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Dist1, Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> Dist1: "+ str(dist1) +" Dist2: "+ str(dist2) 
    explicacion += ". p1 : indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> p1: " + str(p1) 
    explicacion += ". tipo1 : por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo1)
    explicacion = explicacion + ". Columna: nombre de las columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". Params2: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1[0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
        
    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo periódico por una distribución
@app.get("/Datos/drift/periodos/periodico-distr")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, distr2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[distr2,params2], 10, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-dist-periodos.csv"
    
    return response 

# Gráfico de drift de un modelo periódico por una distribución
@app.get("/Plot/drift/periodos/periodico-distr")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, distr2:int, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[distr2,params2], 10, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por un modelo ARMA
@app.get("/reporte/drift/fin/periodico-ARMA")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0,  columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
        
    elif tipo1==2:
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12 
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros1 opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])

        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params1[0] = "+ str(params1[0])+" y b = params1[1] = "+ str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
        
    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c2 = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2)
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
            
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1) 
    explicacion += ". p1: indica la amplitud del periodo (tipo1 1) o la cantidad de periodos (tipo1 2) --> " + str(p1)
    explicacion += ". tipo1: por amplitud (1) / por cantidad (2) --> "+ str(tipo1)
    explicacion = explicacion + ". c2: constante del modelo 2--> " + str(c2)
    explicacion = explicacion + ". s2: amplitud de la estación del modelo 2--> " + str(s2)
    explicacion = explicacion + ". Desv2: desviación típica del ruido blanco del modelo 2--> " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params: parámetros del modelo 2, phi y teta -->"
    if phi2 != []:
        explicacion+= " phi : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= " teta : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])  


    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv de drift de un modelo periódico por un modelo ARMA
@app.get("/Datos/drift/fin/periodico-ARMA")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0,  columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[c2,desv2,s2,phi2,teta2,[]], 11, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-ARMA-fin.csv"
    
    return response

# Gráfico de drift de un modelo periódico por un modelo ARMA
@app.get("/Plot/drift/fin/periodico-ARMA")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0,  columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[c2,desv2,s2,phi2,teta2,[]], 11, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por un modelo ARMA
@app.get("/reporte/drift/periodos/periodico-ARMA")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0,  columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c2 = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2)
    
    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
         
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". dist1: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado (12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1) 
    explicacion += ". p1: indica la amplitud del periodo (tipo1 1) o la cantidad de periodos (tipo1 2) --> " + str(p1)
    explicacion += ". tipo1: por amplitud (1) / por cantidad (2) --> "+ str(tipo1)
    explicacion = explicacion + ". c2: constante del modelo 2--> " + str(c2)
    explicacion = explicacion + ". s2: amplitud de la estación del modelo 2--> " + str(s2)
    explicacion = explicacion + ". Desv2: desviación típica del ruido blanco del modelo 2--> " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". Params: parámetros del modelo 2, phi y teta -->"
    if phi2 != []:
        explicacion+= " phi : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= " teta : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])  

    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv de drift de un modelo periódico por un modelo ARMA
@app.get("/Datos/drift/periodos/periodico-ARMA")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"),params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[c2,desv2,s2,phi2,teta2,[]], 11, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-ARMA-periodos.csv"
    
    return response

# Gráfico de drift de un modelo periódico por un modelo ARMA
@app.get("/Plot/drift/periodos/periodico-ARMA")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, c2:float, desv2:float, s2 : Union[None,int] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"),  phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[c2,desv2,s2,phi2,teta2,[]], 11, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por una tendencia
@app.get("/reporte/drift/fin/periodico-tendencia")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)
        
    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un modelo de tendencia determinista con tendencia "+subtipo2 
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". dist1: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1) 
    explicacion += ". p1: indica la amplitud del periodo (tipo1 1) o la cantidad de periodos (tipo1 2) --> " + str(p1)
    explicacion += ". tipo1: por amplitud (1) / por cantidad (2) --> "+ str(tipo1)
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])

    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda distribución: " : tendencia, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv de drift de un modelo periódico por una tendencia
@app.get("/Datos/drift/fin/periodico-tendencia")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[params2,tipo2,coef_error], 12, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-tendencia-fin.csv"
    
    return response 

# Gráfico de drift de un modelo periódico por una tendencia
@app.get("/Plot/drift/fin/periodico-tendencia")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[tipo1,distr1,params1,p1],[params2,tipo2,coef_error], 12, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo periódico por una tendencia
@app.get("/reporte/drift/periodos/periodico-tendencia")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, dist1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1==1:
        periodicidad1 = "periodos de amplitud " + str(p1)
    elif tipo1==2 :
        periodicidad1 = str(p1)+ " periodos"
        
    if dist1 == 1 :
        subtipo1 = "normal"
        parametros1 ="Modelo con media = params1[0] y desviación típica = params1[1]. La media es " + str(params1[0])+ " y la desviación típica es " + str(params1[1])
        mean1 = params1[0]
        var1 = params1[1] **2
        
    elif dist1 ==2 :
        subtipo1 = "binomial"
        parametros1 = "Modelo con n = params1[0] y p = params1[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params1[0])+" y el valor de p es "+str(params1[1])+ ". Adicionalmente, se puede añadir un desplazamiento params1[2] : "
        if len(params1)==2:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 3:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[2])
        mean1, var1 = binom.stats(params1[0], params1[1], moments='mv')
        if len (params1) == 3 :
           mean1 += params1[2]
           
    elif dist1== 3 :
        subtipo1 = "poisson"
        parametros1 = "Modelo con mu = params1[0] donde mu = parámetro de poisson . El valor de mu es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1= poisson.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
           
    elif dist1 == 4 :
        subtipo1 = "geométrica"
        parametros1 = "Modelo con p = params1[0] donde p = probabilidad de éxito. El valor de p es " + str(params1[0])+". Adicionalmente, se puede añadir un desplazamiento params1[1] : "
        if len(params1)==1:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 2:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[1])
        mean1, var1 = geom.stats(params1[0], moments='mv')
        if len (params1) == 2 :
           mean1 += params1[1]
            
    elif dist1 == 5:
        subtipo1 = "hipergeométrica"
        parametros1 = "Modelo con M = params1[0], n = params1[1] y N = params1[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params1[0])+", el valor de n es " + str(params1[1])+" y el valor de N es " + str(params1[2])+". Adicionalmente, se puede añadir un desplazamiento params1[3] : "
        if len(params1)==3:
            parametros1 += "en este caso no hay desplazamiento"
        elif len(params1) == 4:
            parametros1 += "en este caso es desplazamiento es de " + str(params1[3])
        mean1, var1= hypergeom.stats(params1[0], params1[1],params1[2], moments='mv')
        if len (params1) == 4 :
           mean1 += params1[3]
            
    elif dist1 == 6: 
        subtipo1 ="constante"
        parametros1 = "Modelo con constante = " + str(params1[0])
        mean1 = params1[0]
        var1 = 0
        
    elif dist1 == 7:
        subtipo1 = "uniforme"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params1)==0:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= uniform.stats( moments='mv')
        if len (params1) == 1 :
           mean1 = mean1 + params1[0]
        elif len (params1) == 2:
            mean1 = mean1* params1[1]
            mean1 += params1[0]
            var1 = params1[1]**2/12
            
    elif dist1 == 8:
        subtipo1 = "lognormal"
        parametros1 = "Modelo con s = params1[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución lognormal y escala = escalado de la distribución "
        if len(params1)==1:
            parametros1 += " en este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += " en este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= lognorm.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = lognorm.mean(params1[0], loc=params1[1])
            var1 = lognorm.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = lognorm.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = lognorm.var(params1[0], loc=params1[1], scale=params1[2])
            
    elif dist1 == 9: 
        subtipo1 = "exponencial"
        parametros1 = "Modelo con parametros opcionales: despl = params1[0] y escala = params1[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params1)==0:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 1:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0])
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[0]) +" y la escala de "+str(params1[1])
        mean1, var1= expon.stats( moments='mv')
        if len (params1) == 1 :
            mean1 = expon.mean(loc=params1[0])
        elif len (params1) == 2:
            mean1 = expon.mean(loc=params1[0],scale=params1[1])
            var1 = expon.var(scale=params1[1])
            
    elif dist1 == 10: 
        subtipo1 = "gamma"
        parametros1 = "Modelo con a = params1[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= gamma.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = gamma.mean(params1[0], loc=params1[1])
            var1 = gamma.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = gamma.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = gamma.var(params1[0], scale=params1[2])
            
    elif dist1 == 11: 
        subtipo1 = "beta"
        parametros1 = "Modelo con a = params1[0] y b = params1[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params1[0])+ "y el de b es "+ str(params1[1])+ ". Además, posee los parametros opcionales: despl = params1[] y escala = params1[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params1)==2:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2])
        elif len(params1) == 4:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[2]) +" y la escala de "+str(params1[3])
        mean1, var1= beta.stats(params1[0],params1[1], moments='mv')
        if len (params1) == 3:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2])
            var1 = beta.var(params1[0],params1[1], loc = params1[2])
        elif len (params1) == 4:
            mean1 = beta.mean(params1[0],params1[1], loc=params1[2],scale=params1[3])
            var1 = beta.var(params1[0],params1[1], loc=params1[2], scale=params1[3])
            
    elif dist1 == 12: 
        subtipo1 = "chi cuadrado"
        parametros1 = "Modelo con df = params1[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params1[0]) +". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= chi2.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = chi2.mean(params1[0], loc=params1[1])
            var1 = chi2.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = chi2.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = chi2.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 13: 
        subtipo1 = "t-student"
        parametros1 = "Modelo con v = params1[0] donde v es el parámetro de la distribución t-student. El valor de t es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= t.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = t.mean(params1[0], loc=params1[1])
            var1 = t.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = t.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = t.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 14: 
        subtipo1 = "pareto"
        parametros1 = "Modelo con b = params1[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params1[0])+ ". Además, posee los parametros opcionales: despl = params1[1] y escala = params1[2], donde despl= desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params1)==1:
            parametros1 += "En este caso no hay desplazamiento ni escala "
        elif len(params1) == 2:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1])
        elif len(params1) == 3:
            parametros1 += "En este caso el desplazamiento es de " + str(params1[1]) +" y la escala de "+str(params1[2])
        mean1, var1= pareto.stats(params1[0], moments='mv')
        if len (params1) == 2:
            mean1 = pareto.mean(params1[0], loc=params1[1])
            var1 = pareto.var(params1[0], loc = params1[1])
        elif len (params1) == 3:
            mean1 = pareto.mean(params1[0], loc=params1[1],scale=params1[2])
            var1 = pareto.var(params1[0], loc=params1[1],scale=params1[2])
            
    elif dist1 == 15:
        subtipo1 = "linealmente decreciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 - b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
            
    elif dist1 == 16:
        subtipo1 = "linealmente creciente"
        parametros1 = "Modelo de tipo1: y_i = y_i-1 + b, y_0 = a donde a = params1[0] y b = params1[1]"
        mean1 = "Información no relevante"
        var1 = "Información no relevante"
    
    elif dist1 == 17:
        subtipo1 = "random"
        parametros1 = "Modelo con una distribución con valores aleatorios entre params1[0] = " + str(params1[0]) +" y params1 [1] =" + str(params1[1])
        mean1 = "Información no relevante"
        var1 = "Información no relevante"

    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia = tendencia+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia = tendencia + " + e0"
        tendencia = tendencia + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia = tendencia  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia = tendencia +" y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " e0 es un random con valores entre [- " + str(coef_error)+ " , "+ str(coef_error) +" ]"

    if dist1 !=15 and dist1!= 16 and dist1!=17:
        mean1 = float(mean1)
        var1 = float (var1)

    tipos1 = "Modelo periodico siguiendo una distribución " + subtipo1 + " con " + periodicidad1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " primero siguiendo un " + tipos1 + " y luego un modelo de tendencia determinista con tendencia "+subtipo2 
    explicacion = "Inicio: fecha de inicio --> " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". dist1: normal (1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist1) 
    explicacion += ". p1: indica la amplitud del periodo (tipo1 1) o la cantidad de periodos (tipo1 2) --> " + str(p1)
    explicacion += ". tipo1: por amplitud (1) / por cantidad (2) --> "+ str(tipo1)
    explicacion = explicacion + ". Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo2)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera distribución --> "
    if len(params1)>0: 
        explicacion +=str(params1 [0])
        for k in range (1, len (params1)):
            explicacion = explicacion+", " + str(params1[k])
    explicacion = explicacion + ". params2: parámetros de la tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])

    return {"Tipo": tipos, "Parámetro del modelo 1" : parametros1,"Parámetros de la segunda tendencia: " : tendencia, "Parámetros de la query" : explicacion,"Media primera distribución" :mean1, "Varianza de la primera distribución" : var1}

# Creación csv de drift de un modelo periódico por una tendencia
@app.get("/Datos/drift/periodos/periodico-tendencia")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[params2,tipo2,coef_error], 12, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-periodico-tendencia-periodos.csv"
    
    return response

# Gráfico de drift de un modelo periódico por una tendencia
@app.get("/Plot/drift/periodos/periodico-tendencia")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr1:int, p1:int, tipo2:int,coef_error: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: Optional[List[float]]= Query([],description="Parametros de la primera distribución"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve una gráfica con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo periódico a un modelo de tendencia determinista. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **Dist1, params1** : Indica la distribución a seguir y los parámetros que sigue la primera parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p1**: indica la cantidad de periodos/ la amplitud de los periodos del primer modelo
    - **tipo1**: valores posibles
        1. p1 = amplitud de periodo
        2. p1 = número de periodos
    - **params2**: parámetros de la tendencia.
    - **tipo2**: tipo de la tendencia --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error**: coeficiente de error del modelo de tendencia determinista.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[tipo1,distr1,params1,p1],[params2,tipo2,coef_error], 12, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por otro
@app.get("/reporte/drift/fin/tendencia-tendencia")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,tipo2:int, coef_error1: Union[float, None] = 0,coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia2= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia2= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia2 = tendencia2+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia2 = tendencia2 + " + e0"
        tendencia2 = tendencia2 + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia2 = tendencia2  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia2 = tendencia2 +" y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia2 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia2 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"

    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1, Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1) + " tipo2: " + str(tipo2)
    explicacion = explicacion + ". coef_error1, coef_error2: coeficientes de errores de ambas tendencias (e0) --> coef_error1: " + str(coef_error1)+ " coef_error2: " + str(coef_error2)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])       
    explicacion = explicacion + ". params2: parámetros de la segunda tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])

    return {"Tipo": tipos, "Parámetro de la primera tendencia" : tendencia1,"Parámetros de la segunda tendencia: " : tendencia2, "Parámetros de la query" : explicacion}
  
# Creación csv de drift de un modelo de tendencia determinista por otro
@app.get("/Datos/drift/fin/tendencia-tendencia")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,tipo2:int, coef_error1: Union[float, None] = 0,coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[params2,tipo2,coef_error2], 13, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-tendencia-fin.csv"
    
    return response

# Gráfico de drift de un modelo de tendencia determinista por otro
@app.get("/Plot/drift/fin/tendencia-tendencia")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,tipo2:int, coef_error1: Union[float, None] = 0,coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[params2,tipo2,coef_error2], 13, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por otro
@app.get("/reporte/drift/periodos/tendencia-tendencia")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int,tipo2:int, coef_error1: Union[float, None] = 0,coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if tipo2 == 1:
        subtipo2 = "lineal"
        tendencia2= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params2[0]) + ", b = " +str (params2[1]) +" y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 ==2:
        subtipo2 ="polinómica de grado "+ str(len(params2)-1)
        tendencia2= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params2)):
            tendencia2 = tendencia2+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia2 = tendencia2 + " + e0"
        tendencia2 = tendencia2 + " donde a = " + str(params2[0]) + ", b[1] = " + str (params2[1])
        for k in range (2,len(params2)):
            tendencia2 = tendencia2  + ", b["+ str(k)+"] = " + str (params2[k])
        tendencia2 = tendencia2 +" y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 == 3: 
        subtipo2 ="exponencial"
        tendencia2 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"
    elif tipo2 == 4:
        subtipo2 = "logaritmica" 
        tendencia2 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params2[0]) + ", b = " + str(params2[1]) + " y e0 es un random con valores entre [- " + str(coef_error2)+ " , "+ str(coef_error2) +" ]"

    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos2 = "modelo de tendencia determinista con tendencia " + subtipo2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1, Tipo2: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1) + " tipo2: " + str(tipo2)
    explicacion = explicacion + ". coef_error1, coef_error2: coeficientes de errores de ambas tendencias (e0) --> coef_error1: " + str(coef_error1)+ " coef_error2: " + str(coef_error2)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])       
    explicacion = explicacion + ". params2: parámetros de la segunda tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params2 [0])
    for k in range (1, len (params2)):
        explicacion = explicacion+", " + str(params2 [k])

    return {"Tipo": tipos, "Parámetro de la primera tendencia" : tendencia1,"Parámetros de la segunda tendencia: " : tendencia2, "Parámetros de la query" : explicacion}

# Creación csv de drift de un modelo de tendencia determinista por otro
@app.get("/Datos/drift/periodos/tendencia-tendencia")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, tipo2:int, coef_error1: Union[float, None] = 0, coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[params2,tipo2,coef_error2], 13, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-tendencia-periodos.csv"
    
    return response

# Gráfico de drift de un modelo de tendencia determinista por otro
@app.get("/Plot/drift/periodos/tendencia-tendencia")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, tipo2:int, coef_error1: Union[float, None] = 0, coef_error2: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda tendencia")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a otro. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **params2**: parámetros de la tendencia 2.
    - **tipo2**: tipo de la tendencia 2 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error2**: coeficiente de error del modelo de tendencia determinista 2.
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[params2,tipo2,coef_error2], 13, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por una distribución
@app.get("/reporte/drift/fin/tendencia-distr")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,dist2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2) 
    
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego una distribución "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1)
    explicacion = explicacion + ". coef_error1: coeficientes de errores de e la tendencia (e0) --> coef_error1: " + str(coef_error1)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])    
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo de tendencia determinista por una distribución
@app.get("/Datos/drift/fin/tendencia-distr")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,distr2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[distr2,params2], 14, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-dist-fin.csv"
    
    return response

# Gráfico de drift de un modelo de tendencia determinista por una distribución
@app.get("/Plot/drift/fin/tendencia-distr")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,distr2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[distr2,params2], 14, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por una distribución
@app.get("/reporte/drift/periodos/tendencia-distr")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int,dist2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: Optional[List[float]]= Query([],description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego una distribución "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1)
    explicacion = explicacion + ". coef_error1: coeficientes de errores de e la tendencia (e0) --> coef_error1: " + str(coef_error1)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])    
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo de tendencia determinista por una distribución
@app.get("/Datos/drift/periodos/tendencia-distr")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[distr2,params2], 14, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-dist-periodos.csv"
    return response 

# Gráfico de drift de un modelo de tendencia determinista por una distribución
@app.get("/Plot/drift/periodos/tendencia-distr")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, distr2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a una distribución. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[distr2,params2], 14, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por uno ARMA
@app.get("/reporte/drift/fin/tendencia-ARMA")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
       
    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c2 = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2) 
        
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer modelo " + tipos1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo1)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error1)
    explicacion = explicacion + ". c2: constante del modelo 2--> " + str(c2)
    explicacion = explicacion + ". s2: amplitud de la estación del modelo 2 --> " + str(s2)
    explicacion = explicacion + ". Desv2: desviación típica del ruido blanco del modelo 2--> " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la tendencia, a = params1 [0] y b[k] = params1[k] --> "+str(params1 [0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1 [k])
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi2 != []:
        explicacion+= " phi : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= " teta : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])
            
    explicacion = explicacion + ". params1: parámetros de la tendencia, a = params1 [0] y b[k] = params1[k] --> "+str(params1 [0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1 [k])

    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros del modelo 2" : parametros2, "Parámetros de la query" : explicacion}

# Creación csv de drift de un modelo de tendencia determinista por uno ARMA 
@app.get("/Datos/drift/fin/tendencia-ARMA")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[c2,desv2,s2,phi2,teta2,[]], 15, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-ARMA-fin.csv"
    return response 

# Gráfico de drift de un modelo de tendencia determinista por uno ARMA
@app.get("/Plot/drift/fin/tendencia-ARMA")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int,c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[c2,desv2,s2,phi2,teta2,[]], 15, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por uno ARMA
@app.get("/reporte/drift/periodos/tendencia-ARMA")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int,c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"      
       
    if phi2 == []:
        subtipo2 = "de medias móviles"
        parametros2= "La serie sigue una distribución de medias móviles con constante c2 = "+ str(c2)+" y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
           
    elif teta2 ==[]:
        subtipo2 = "autorregresivo"
        parametros2= "La serie sigue una distribución autorregresiva con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
    else: 
        subtipo2 ="autorregresivo y de medias móviles"
        parametros2 = "La serie sigue una distribución autorregresiva y de medias móviles con constante c2 = "+ str(c2)+" y con valores de phi2: phi2_0 " + str(phi2[0])
        for k in range (1,len(phi2)):
           parametros2 = parametros2  + " phi2_"+ str(k)+" = " + str (phi2[k])
        parametros2 = parametros2 + " y con valores de teta2: teta2_0 " + str(teta2[0])
        for k in range (1,len(teta2)):
           parametros2 = parametros2  + " teta2_"+ str(k)+" = " + str (teta2[k])
    if s2 != 0:
        subtipo2 += " estacional con amplitud de la estación: " + str(s2) 
        
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer modelo " + tipos1 + " y luego un modelo "+ subtipo2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> " + str(tipo1)
    explicacion = explicacion + ". Error: coeficiente de error (e0) --> " + str(coef_error1)
    explicacion = explicacion + ". c2: constante del modelo 2--> " + str(c2)
    explicacion = explicacion + ". s2: amplitud de la estación del modelo 2 --> " + str(s2)
    explicacion = explicacion + ". Desv2: desviación típica del ruido blanco del modelo 2--> " + str(desv2)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la tendencia, a = params1 [0] y b[k] = params1[k] --> "+str(params1 [0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1 [k])
    explicacion = explicacion + ". Params: parámetros del modelo 1, phi y teta -->"
    if phi2 != []:
        explicacion+= " phi : " + str(phi2[0])
        for k in range (1, len (phi2)):
            explicacion = explicacion+", " + str(phi2[k])
    if teta2!=[]:
        explicacion+= " teta : " + str(teta2[0])
        for k in range (1, len (teta2)):
            explicacion = explicacion+", " + str(teta2[k])
            
    explicacion = explicacion + ". params1: parámetros de la tendencia, a = params1 [0] y b[k] = params1[k] --> "+str(params1 [0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1 [k])

    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros del modelo 2" : parametros2, "Parámetros de la query" : explicacion}

# Creación csv de drift de un modelo de tendencia determinista por uno ARMA
@app.get("/Datos/drift/periodos/tendencia-ARMA")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"),phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df =crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[c2,desv2,s2,phi2,teta2,[]], 15, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-ARMA-periodos.csv"
    return response 

# Gráfico de drift de un modelo de tendencia determinista por uno ARMA
@app.get("/Plot/drift/periodos/tendencia-ARMA")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, c2:float,desv2:float,s2: Union[int,None] = 0, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"),phi2: Optional[List[float]]= Query([],description="Parámetros autorregresivos 2"), teta2:Optional[List[float]]= Query([],description="Parámetros medias móviles 2")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo autorregresivo y de medias móviles. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **c2, phi2, teta2** : parámetros de los modelo autorregresivos y de medias móviles 2. c2 --> constante, phi --> parámetros del modelo autorregresivo y teta --> parámetros del modelo de medias móviles
    - **s2** : estacionalidad, tamaño de una estación (número de datos que hay en cada estación) del modelo 2
    - **desv2**: desviación típica del ruido blanco del modelo 2
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[c2,desv2,s2,phi2,teta2,[]], 15, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por uno periódico
@app.get("/reporte/periodos/fin/tendencia-periodico")
async def obtener_reporte(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, tipo2:int, dist2:int, p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if tipo2==1:
        periodicidad2 = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad2 = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
        
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
        
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Fin: fecha de fin --> "+ str(fin)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1)
    explicacion = explicacion + ". coef_error1: coeficientes de errores de e la tendencia (e0) --> coef_error1: " + str(coef_error1)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta (11), chi cuadrado (12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". p2 : indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> " + str(p2) 
    explicacion += ". Tipo2 : por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo2)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])    
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo de tendencia determinista por uno periódico
@app.get("/Datos/drift/fin/tendencia-periodico")
async def obtener_datos(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, tipo2:int, distr2:int, p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[tipo2,distr2,params2,p2], 16, num_drift)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-periodico-fin.csv"
    return response 

# Gráfico de drift de un modelo de tendencia determinista por uno periódico
@app.get("/Plot/drift/fin/tendencia-periodico")
async def obtener_grafica(inicio: str, fin:str, freq:str, num_drift:int, tipo1:int, tipo2:int, distr2:int, p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **fin**: fecha de fin.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_fin_DRIFT(inicio,fin,freq,columna,[params1,tipo1,coef_error1],[tipo2,distr2,params2,p2], 16, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# reporte estadístico de drift de un modelo de tendencia determinista por uno periódico
@app.get("/reporte/drift/periodos/tendencia-periodico")
async def obtener_reporte(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int, tipo2:int, dist2:int, p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float] = Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un reporte estadístico sobre los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    if tipo1 == 1:
        subtipo1 = "lineal"
        tendencia1= "La serie es de tipo y = a + t * b + e0 donde a = " + str(params1[0]) + ", b = " +str (params1[1]) +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 ==2:
        subtipo1 ="polinómica de grado "+ str(len(params1)-1)
        tendencia1= "La serie es de tipo y = a + b[1] * t"  
        for k in range (2,len(params1)):
            tendencia1 = tendencia1+ " + b ["+str(k)+"] * t ** " + str(k)
        tendencia1 = tendencia1 + " + e0"
        tendencia1 = tendencia1 + " donde a = " + str(params1[0]) + ", b[1] = " + str (params1[1])
        for k in range (2,len(params1)):
            tendencia1 = tendencia1  + ", b["+ str(k)+"] = " + str (params1[k])
        tendencia1 = tendencia1 +" y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 == 3: 
        subtipo1 ="exponencial"
        tendencia1 = "La serie es de tipo y = e ** (a + b*t + e0) donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " y e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"
    
    elif tipo1 == 4:
        subtipo1 = "logaritmica" 
        tendencia1 = "La serie es de tipo y = a + b * log(t) + e0 donde a = " + str(params1[0]) + ", b = " + str(params1[1]) + " e0 es un random con valores entre [- " + str(coef_error1)+ " , "+ str(coef_error1) +" ]"

    if tipo2==1:
        periodicidad2 = "periodos de amplitud " + str(p2)
    elif tipo2==2 :
        periodicidad2 = str(p2)+ " periodos"
        
    if dist2 == 1 :
        subtipo2 = "normal"
        parametros2 ="Modelo con media = params2[0] y desviación típica = params2[1]. La media es " + str(params2[0])+ " y la desviación típica es " + str(params2[1])
        mean2 = params2[0]
        var2 = params2[1] **2
        
    elif dist2 ==2 :
        subtipo2 = "binomial"
        parametros2 = "Modelo con n = params2[0] y p = params2[1] donde n = número de pruebas y p = probabilidad de éxito. El valor de n es " + str(params2[0])+" y el valor de p es "+str(params2[1])+ ". Adicionalmente, se puede añadir un desplazamiento params2[2]: "
        if len(params2)==2:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 3:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[2])
        mean2, var2 = binom.stats(params2[0], params2[1], moments='mv')
        if len (params2) == 3 :
           mean2 += params2[2]
           
    elif dist2== 3 :
        subtipo2 = "poisson"
        parametros2 = "Modelo con mu = params2[0] donde mu = parámetro de poisson . El valor de mu es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2= poisson.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
           
    elif dist2 == 4 :
        subtipo2 = "geométrica"
        parametros2 = "Modelo con p = params2[0] donde p = probabilidad de éxito. El valor de p es " + str(params2[0])+". Adicionalmente, se puede añadir un desplazamiento params2[1]: "
        if len(params2)==1:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 2:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[1])
        mean2, var2 = geom.stats(params2[0], moments='mv')
        if len (params2) == 2 :
           mean2 += params2[1]
            
    elif dist2 == 5:
        subtipo2 = "hipergeométrica"
        parametros2 = "Modelo con M = params2[0], n = params2[1] y N = params2[2], donde M = tamaño población, n = exitosos en la población y N = tamaño muesta. El valor de M es " + str(params2[0])+", el valor de n es " + str(params2[1])+" y el valor de N es " + str(params2[2])+". Adicionalmente, se puede añadir un desplazamiento params2[3]: "
        if len(params2)==3:
            parametros2 += "en este caso no hay desplazamiento"
        elif len(params2) == 4:
            parametros2 += "en este caso es desplazamiento es de " + str(params2[3])
        mean2, var2= hypergeom.stats(params2[0], params2[1],params2[2], moments='mv')
        if len (params2) == 4 :
           mean2 += params2[3]
            
    elif dist2 == 6: 
        subtipo2 ="constante"
        parametros2 = "Modelo con constante = " + str(params2[0])
        mean2 = params2[0]
        var2 = 0
        
    elif dist2 == 7:
        subtipo2 = "uniforme"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución uniforme y obteniendo una distribucion uniforme [despl,despl+escala],"
        if len(params2)==0:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= uniform.stats( moments='mv')
        if len (params2) == 1 :
           mean2 = mean2 + params2[0]
        elif len (params2) == 2:
            mean2 = mean2* params2[1]
            mean2 += params2[0]
            var2 = params2[1]**2/12
            
    elif dist2 == 8:
        subtipo2 = "lognormal"
        parametros2 = "Modelo con s = params2[0] donde s es el parámetro de la distribución lognormal. El valor de s es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución lognormal y escala = escalado de la distribución, "
        if len(params2)==1:
            parametros2 += " en este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += " en este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= lognorm.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = lognorm.mean(params2[0], loc=params2[1])
            var2 = lognorm.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = lognorm.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = lognorm.var(params2[0], loc=params2[1], scale=params2[2])
            
    elif dist2 == 9: 
        subtipo2 = "exponencial"
        parametros2 = "Modelo con parametros opcionales: despl = params2[0] y escala = params2[1], donde despl= desplazamiento de la distribución exponencial y escala = escalado de la distribución. "
        if len(params2)==0:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 1:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0])
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[0]) +" y la escala de "+str(params2[1])
        mean2, var2= expon.stats( moments='mv')
        if len (params2) == 1 :
            mean2 = expon.mean(loc=params2[0])
        elif len (params2) == 2:
            mean2 = expon.mean(loc=params2[0],scale=params2[1])
            var2 = expon.var(scale=params2[1])
            
    elif dist2 == 10: 
        subtipo2 = "gamma"
        parametros2 = "Modelo con a = params2[0] donde a es el parámetro de la distribución gamma. El valor de a es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl= desplazamiento de la distribución gamma y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= gamma.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = gamma.mean(params2[0], loc=params2[1])
            var2 = gamma.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = gamma.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = gamma.var(params2[0], scale=params2[2])
            
    elif dist2 == 11: 
        subtipo2 = "beta"
        parametros2 = "Modelo con a = params2[0] y b = params2[1] donde a y b son los parámetros de la distribución beta. El valor de a es "+ str(params2[0])+ "y el de b es "+ str(params2[1])+ ". Además, posee los parametros opcionales: despl = params2[] y escala = params2[1], donde despl= desplazamiento de la distribución beta y escala = escalado de la distribución. "
        if len(params2)==2:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2])
        elif len(params2) == 4:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[2]) +" y la escala de "+str(params2[3])
        mean2, var2= beta.stats(params2[0],params2[1], moments='mv')
        if len (params2) == 3:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2])
            var2 = beta.var(params2[0],params2[1], loc = params2[2])
        elif len (params2) == 4:
            mean2 = beta.mean(params2[0],params2[1], loc=params2[2],scale=params2[3])
            var2 = beta.var(params2[0],params2[1], loc=params2[2], scale=params2[3])
            
    elif dist2 == 12: 
        subtipo2 = "chi cuadrado"
        parametros2 = "Modelo con df = params2[0] donde df es el parámetro de la distribución chi cuadrado. El valor de df es "+ str(params2[0]) +". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución chi2 y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= chi2.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = chi2.mean(params2[0], loc=params2[1])
            var2 = chi2.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = chi2.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = chi2.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 13: 
        subtipo2 = "t-student"
        parametros2 = "Modelo con v = params2[0] donde v es el parámetro de la distribución t-student. El valor de v es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución t-student y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= t.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = t.mean(params2[0], loc=params2[1])
            var2 = t.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = t.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = t.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 14: 
        subtipo2 = "pareto"
        parametros2 = "Modelo con b = params2[0] donde b es el parámetro de la distribución pareto. El valor de b es "+ str(params2[0])+ ". Además, posee los parametros opcionales: despl = params2[1] y escala = params2[2], donde despl = desplazamiento de la distribución pareto y escala = escalado de la distribución. "
        if len(params2)==1:
            parametros2 += "En este caso no hay desplazamiento ni escala "
        elif len(params2) == 2:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1])
        elif len(params2) == 3:
            parametros2 += "En este caso el desplazamiento es de " + str(params2[1]) +" y la escala de "+str(params2[2])
        mean2, var2= pareto.stats(params2[0], moments='mv')
        if len (params2) == 2:
            mean2 = pareto.mean(params2[0], loc=params2[1])
            var2 = pareto.var(params2[0], loc = params2[1])
        elif len (params2) == 3:
            mean2 = pareto.mean(params2[0], loc=params2[1],scale=params2[2])
            var2 = pareto.var(params2[0], loc=params2[1],scale=params2[2])
            
    elif dist2 == 15:
        subtipo2 = "linealmente decreciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 - b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
            
    elif dist2 == 16:
        subtipo2 = "linealmente creciente"
        parametros2 = "Modelo de tipo: y_i = y_i-1 + b, y_0 = a donde a = params2[0] = "+ str(params2[0])+" y b = params2[1] = "+ str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    elif dist2 == 17:
        subtipo2 = "random"
        parametros2 = "Modelo con una distribución con valores aleatorios entre params2[0] = " + str(params2[0]) +" y params2 [1] =" + str(params2[1])
        mean2 = "Información no relevante"
        var2 = "Información no relevante"
    
    if dist2 !=15 and dist2!= 16 and dist2!=17:
        mean2 = float(mean2)
        var2 = float (var2)
    
    tipos1 = "modelo de tendencia determinista con tendencia " + subtipo1
    tipos2 = "Modelo periodico siguiendo una distribución " + subtipo2 + " con " + periodicidad2
    tipos = "Modelo que sufre drift en el dato " + str(num_drift) + " siguiendo un primer " + tipos1 + " y luego un "+ tipos2
    explicacion = "Inicio: fecha de inicio " + str(inicio)
    explicacion = explicacion +". Periodos: número de datos a generar --> "+ str(periodos)
    explicacion = explicacion + ". Freq: frequencia de la serie temporal --> " + str(freq)
    explicacion = explicacion + ". Tipo1: lineal(1), polinómica(2), exponencial(3), logarítmica(4) --> tipo1: " + str(tipo1)
    explicacion = explicacion + ". coef_error1: coeficientes de errores de e la tendencia (e0) --> coef_error1: " + str(coef_error1)
    explicacion = explicacion + ". Dist2: normal(1), binomial(2), poisson(3), geométrica(4), hipergeométrica(5), constante(6), uniforme(7), lognormal(8), exponencial(9), gamma(10), beta(11), chi cuadrado(12), t-student(13), pareto(14), linealmente decreciente(15), linealmente creciente(16) y random(17) --> "+ str(dist2) 
    explicacion += ". p2: indica la amplitud del periodo (tipo=1) o la cantidad de periodos (tipo=2) --> " + str(p2) 
    explicacion += ". Tipo2 : por amplitud (1) / por cantidad (2) --> tipo1: "+ str(tipo2)
    explicacion += ". num_drift: dato en el que se produce el cambio de distribución --> " + str(num_drift)
    explicacion = explicacion + ". Columna: nombre de la columnas --> " + columna[0]
    for k in range (1, len (columna)):
        explicacion = explicacion+", " + columna [k]
    explicacion = explicacion + ". params1: parámetros de la primera tendencia, a = params2 [0] y b[k] = params2[k] --> "+str(params1[0])
    for k in range (1, len (params1)):
        explicacion = explicacion+", " + str(params1[k])    
    explicacion = explicacion + ". Params2: parámetros de la segunda distribución --> "
    if len(params2)>0: 
        explicacion +=str(params2 [0])
        for k in range (1, len (params2)):
            explicacion = explicacion+", " + str(params2[k])
    return {"Tipo": tipos, "Parámetro del modelo 1" : tendencia1,"Parámetros de la segunda distribución: " : parametros2, "Parámetros de la query" : explicacion, "Media segunda distribución" :mean2, "Varianza de la segunda distribución" : var2}

# Creación csv de drift de un modelo de tendencia determinista por uno periódico
@app.get("/Datos/drift/periodos/tendencia-periodico")
async def obtener_datos(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int,tipo2:int, distr2:int,p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve un csv con los datos generados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[tipo2,distr2,params2,p2], 16, num_drift)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=datos-drift-tendencia-periodico-periodos.csv"
    return response 

# Gráfico de drift de un modelo de tendencia determinista por uno periódico
@app.get("/Plot/drift/periodos/tendencia-periodico")
async def obtener_grafica(inicio: str, periodos:int, freq:str, num_drift:int, tipo1:int,tipo2:int, distr2:int,p2:int, coef_error1: Union[float, None] = 0, columna: List[str]= Query(...,description="Nombres de las columnas"), params1: List[float]= Query(...,description="Parametros de la primera tendencia"), params2: List[float]= Query(...,description="Parametros de la segunda distribución")):
    """
    Devuelve una imagen con los datos graficados a partir de un modelo que sufre un drift cambiando de un modelo de tendencia determinista a un modelo periódico. Parámetros:

    - **inicio**: fecha de inicio.
    - **periodos**: número de datos a generar.
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num_drift**: dato en el que se produce el drift.
    - **params1**: parámetros de la tendencia 1.
    - **tipo1**: tipo de la tendencia 1 --> lineal (1), polinómica (2), exponencial (3) y logarítmica (4)
    - **coef_error1**: coeficiente de error del modelo de tendencia determinista 1.
    - **Dist2, params2** : Indica la distribución a seguir y los parámetros que sigue la segunda parte de los datos. Casos:
        1. Normal: Los parámetros son la media y la desv_típica de los datos.
        2. Binomial: Los parámetros son n (nº pruebas) y p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        3. Poisson: El parámetro es mu. Además, podemos añadir otro parámetro que indica la localización de los datos.
        4. Geómetrica: El parámetro es p (probabilidad éxito). Además, podemos añadir otro parámetro que indica la localización de los datos.
        5. Hipergeómetrica: Los parámetros son M (tamaño población), n (nº aciertos) y N (tamaño muestra). Además, podemos añadir otro parámetro que indica la localización de los datos.
        6. Constante: El parámetro es el valor constante que toma los datos.
        7. Uniforme: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        8. Lognormal: El parámetro es s. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        9. Exponencial: Puede no tener parámetros, indicar solo la localización o indicar la localización y escala. 
        10. Gamma: El parámetro es a. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        11. Beta: Los parámetros son a y b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        12. Chi-Cuadrado: El parámetro es df. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        13. T-Student: El parámetro es t. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        14. Pareto: El parámetro es b. Además, podemos añadir otros parámetros que indican la localización o localización y escala de los datos.
        15. Lineal descendente: Los parámetros son el dato inicial y la pendiente (en valor absoluto). El mínimo valor posible es cero, si se alcanza los datos se mantienen constante con ese valor. 
        16. Lineal ascendente: Los parámetros son el dato inicial y la pendiente. 
        17. Aleatorio: Obtiene números aleatorios cuyos valores oscilan entre el primer parámetro y el segundo
    - **p2**: indica la cantidad de periodos/ la amplitud de los periodos del segundo modelo
    - **tipo2**: valores posibles
        1. p2 = amplitud de periodo
        2. p2 = número de periodos
    - **columna**: nombre de la columna con los datos generados.
    """
    df = crear_df_periodos_DRIFT(inicio,periodos,freq,columna,[params1,tipo1,coef_error1],[tipo2,distr2,params2,p2], 16, num_drift)
    plot_df(df)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()

    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos a partir de una relación lineal de los datos previos.
@app.post("/Variables/Lineal")
async def obtener_datos(a : float, b: float, indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación lineal respecto a la columna ya existente:
    - **a**, **b** : coeficientes de la relación lineal (a + b*x*)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """
    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_lineal(df,a,b, columna)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-lineal.csv"
    return response 
 
# Gráfica de datos obtenidos a partir de una relación lineal.   
@app.post("/Plot/Variables/Lineal")
async def obtener_grafica(a : float, b: float, indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación lineal respecto a la columna ya existente:
    - **a**, **b** : coeficientes de la relación lineal (a + b*x*)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_lineal(df,a,b, columna)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos a partir de una relación polinómica de los datos previos.
@app.post("/Variables/Polinomico")
async def obtener_datos (indice:str, columna:str, a: List[float]= Query(...,description="Coeficientes"), file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación polinómica respecto a la columna ya existente. Parámetros:
    - **a** : coeficiente de la relación polinómica (a[0] + a[1]*x* + a[2]*x*<sup>2</sup> + a[3]*x*<sup>3</sup> ...)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = objetivo_polinomico(df,a, columna)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-polinomico.csv"
    return response 

# Gráfica de datos obtenidos a partir de una relación polinómica de los datos previos.
@app.post("/Plot/Variables/Polinomico")
async def obtener_grafica( indice:str, columna:str, a: List[float]= Query(...,description="Coeficientes"), file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación polinómica respecto a la columna ya existente. Parámetros:
    - **a** : coeficiente de la relación polinómica (a[0] + a[1]*x* + a[2]*x*<sup>2</sup> + a[3]*x*<sup>3</sup> ...)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_polinomico(df,a, columna)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos a partir de una relación exponencial de los datos previos.
@app.post("/Variables/Exponencial")
async def obtener_datos( a:float,b:float,indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación exponencial respecto a la columna ya existente. Parámetros:
    - **a**, **b** : coeficientes de la relación exponencial (a + e*<sup>bx</sup>)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """       
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_exp(df,a,b, columna)    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-exponencial.csv"
    return response 

# Gráfica de datos obtenidos a partir de una relación exponencial de los datos previos.
@app.post("/Plot/Variables/Exponencial")
async def obtener_grafica( a:float,b:float,indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación exponencial respecto a la columna ya existente. Parámetros:
    - **a**, **b** : coeficientes de la relación exponencial (a + e*<sup>bx</sup>)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """  
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_exp(df,a,b, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación de datos obtenidos a partir de una relación logarítmica de los datos previos.
@app.post("/Variables/Logaritmica")
async def obtener_datos( a:float,b:float,indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación logarítmica respecto a la columna ya existente. Parámetros:
    - **a**, **b** : coeficientes de la relación logarítmica (a+ b log(x))
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """     
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_log(df,a,b, columna)    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-logaritmico.csv"
    return response 

# Gráfica de datos obtenidos a partir de una relación logarítmica de los datos previos.
@app.post("/Plot/Variables/Logaritmica")
async def obtener_grafica( a:float,b:float,indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación logarítmica respecto a la columna ya existente. Parámetros:
    - **a**, **b** : coeficientes de la relación logarítmica (a+ b log(x))
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariables
    """  
    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_log(df,a,b, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos como combinación lineal de los otros
@app.post("/Variables/Multivariante")
async def obtener_datos(a:float, indice:str, columna:str, b :List[float]= Query(...,description="Coeficientes"), file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación lineal multivariable respecto a las columnas ya existentes. Parámetros:
    - **a** , **b** : coeficientes de la relación lineal multivariable (a+ ∑<sub>i=1</sub> b[i]x[i])
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariables
    """      
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = multivariante(df,a,b, columna)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-multivariante.csv"
    return response 

# Gráfica de datos obtenidos como combinación lineal de los otros
@app.post("/Plot/Variables/Multivariante")
async def obtener_grafica(a:float, indice:str, columna:str, b :List[float]= Query(...,description="Coeficientes"), file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación lineal multivariable respecto a las columnas ya existentes. Parámetros:
    - **a** , **b** : coeficientes de la relación lineal multivariable (a+ ∑<sub>i=1</sub> b[i]x[i])
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariables
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = multivariante(df,a,b, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

    
# Creación de datos obtenidos tras aplicar una matriz de interacción para obtener nuevos datos
@app.post("/Variables/Interaccion")
async def obtener_datos(a:float, indice:str, columna:str, b: str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación basada en la matriz respecto a las columnas ya existentes. Parámetros:
    - **a** , **b** : coeficientes de la relación (a+ ∑<sub>i=1</sub> b[i][i]x[i] + ∑<sub>j=1,k=1</sub> b[j][k]x[j]x[k] )
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariables
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    b1 = json.loads(b)
    m = np.zeros((len(b1),len(b1)))
    for i in range(0,m.shape[0]):
        for j in range(0,m.shape[1]):
            m[i][j] = b1[i][j]
    df1 = interaccion(df,a,m, columna)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-interaccion.csv"
    return response 

# Gráfico de datos obtenidos tras aplicar una matriz de correlación para obtener nuevos datos
@app.post("/Plot/Variables/Interaccion")
async def obtener_grafica(a:float, indice:str, columna:str, b: str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación basada en la matriz respecto a las columnas ya existentes. Parámetros:
    - **a** , **b** : coeficientes de la relación (a+ ∑<sub>i=1</sub> b[i][i]x[i] + ∑<sub>j=1,k=1</sub> b[j][k]x[j]x[k] )
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariables
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    b1 = json.loads(b)
    m = np.zeros((len(b1),len(b1)))
    for i in range(0,m.shape[0]):
        for j in range(0,m.shape[1]):
            m[i][j] = b1[i][j]

    df1 = interaccion(df,a,m, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos tras aplicar la inversa a los datos previos
@app.post("/Variables/Inversa")
async def obtener_datos(a:float, n:int , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación inversa respecto a la columna ya existente. Parámetros:
    - **a** , **n** : coeficiente de la relación y grado (a / x<sup>n</sup>)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_prop_inversa(df,a,n, columna)    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-inversa.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar la inversa a los datos previos
@app.post("/Plot/Variables/Inversa")
async def obtener_grafica(a:float, n:int , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación inversa respecto a la columna ya existente. Parámetros:
    - **a** , **n** : coeficiente de la relación y grado (a / x<sup>n</sup>)
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_prop_inversa(df,a, n, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv con datos obtenidos tras aplicar una función u otra según la variable sea mayor / menor que un umbral    
@app.post("/Variables/Escalonada")
async def obtener_datos(umbral:float, f: str, g:str , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación escalonada respecto a la columna ya existente. Parámetros:
    - **umbral** : valor umbral (si x < umbral --> f(x), si x>= umbral --> g(x))
    - **f** , **g** : funciones que se usan para obtener el valor de la nueva columna 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    f1 = elegir_funcion(f)
    g1 = elegir_funcion(g)
    df1 = objetivo_escalonada(df,f1,g1, umbral,columna)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-escalonada.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar una función u otra según la variable sea mayor / menor que un umbral 
@app.post("/Plot/Variables/Escalonada")
async def obtener_grafica(umbral:float, f: str,g:str , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados a partir de una relación escalonada respecto a la columna ya existente. Parámetros:
    - **umbral** : valor umbral (si x < umbral --> f(x), si x>= umbral --> g(x))
    - **f** , **g** : funciones que se usan para obtener el valor de la nueva columna 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos univariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    f1 = elegir_funcion(f)
    g1 = elegir_funcion(g)
    df1 = objetivo_escalonada(df,f1,g1,umbral, columna)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")
  

# Creación de datos obtenidos tras aplicar una función a una combinación lineal de las variables dependiendo de ciertas condiciones
@app.post("/Variables/Condicional")
async def obtener_datos( funciones: List[str],condiciones: List[str] , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos añadiendole una columna a partir de una relación condicional respecto a las columnas ya existentes. Parámetros:
    - **funciones** : array con las funciones aplicadas en caso de que se cumpla la condición correspondiente. Valores posibles de cada función:
        1. *Lineal*: relación lineal respecto al resto de las variables
        2. *Polinomica2*: relación polinómica de grado 2 respecto al resto de las variables
        3. *Polinomica3*: relación polinómica de grado 3 respecto al resto de las variables
        4. *Polinomica4*: relación polinómica de grado 4 respecto al resto de las variables
        5. *Exponencial*: relación exponencial respecto a una relación lineal del resto de variables 
        6. *Exponencial2*: relación exponencial de base 2 respecto a una relación lineal del resto de variables 
        7. *Log*: relación logarítmica respecto a una relación lineal del resto de variables 
        8. *Raiz*: relación radical respecto a una relación lineal del resto de variables 
        9. *Seno*: relación senoidal respecto a una relación lineal del resto de variables 
        10. *Coseno*: relación cosenoidal respecto a una relación lineal del resto de variables 
        11. *Tangente*: relación tangencial respecto a una relación lineal del resto de variables 
        12. *Absoluto*: valor absoluto respecto a una relación lineal del resto de variables 
        13. *Truncar*: truncar respecto a una relación lineal del resto de variables 
        14. *Log10*: logarítmo en base 10 de una relación lineal del resto de variables 
        15. *Log1p*: logaritmo de una relación lineal del resto de variables 
        16. *Log2*: logaritmo en base 2 de una relación lineal del resto de variables 
        17. *Ceil*: parte entera de una relación lineal del resto de variables 
    - **condiciones** : array con las condiciones. Valores posibles:
        1. indice + Menor/Mayor/Igual/Menor=/Mayor= + valor: comprueba que el valor de la columna correspondiente al indice sea menor/mayor/igual/menor o igual/mayor o igual que el valor
        2. indice1 + Menores/Mayores/Iguales/Menores=/Mayores= + indice2: comprueba que el valor de la columna correspondiente al indice1 sea menor/mayor/igual/menor o igual/mayor o igual que el valor de la columna correspondiente al indice2
        3. default: siempre se cumple
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    Nota: Debe haber tantas funciones como condiciones. Si se cumple la n-ésima condición, entonces el valor de la nueva columna se obtiene de aplicar la n-ésima función
    """  
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    func = funciones[0].split(",")
    cond = condiciones[0].split(",")
    f = list()
    c = list ()
    for k in range(0,len(func)):
        f.append(elegir_funcion_multi(func[k]))
        
    for k in range(0, len(cond)):
        c.append(elegir_condicion(cond[k]))
        
    df1 = objetivo_condicional(df,columna,c,f)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-condicional.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar una función a una combinación lineal de las variables dependiendo de ciertas condiciones
@app.post("/Plot/Variables/Condicional")
async def obtener_grafica( funciones: List[str],condiciones: List[str] , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación condicional respecto a las columnas ya existentes. Parámetros:
    - **funciones** : array con las funciones aplicadas en caso de que se cumpla la condición correspondiente. Valores posibles de cada función:
        1. *Lineal*: relación lineal respecto al resto de las variables
        2. *Polinomica2*: relación polinómica de grado 2 respecto al resto de las variables
        3. *Polinomica3*: relación polinómica de grado 3 respecto al resto de las variables
        4. *Polinomica4*: relación polinómica de grado 4 respecto al resto de las variables
        5. *Exponencial*: relación exponencial respecto a una relación lineal del resto de variables 
        6. *Exponencial2*: relación exponencial de base 2 respecto a una relación lineal del resto de variables 
        7. *Log*: relación logarítmica respecto a una relación lineal del resto de variables 
        8. *Raiz*: relación radical respecto a una relación lineal del resto de variables 
        9. *Seno*: relación senoidal respecto a una relación lineal del resto de variables 
        10. *Coseno*: relación cosenoidal respecto a una relación lineal del resto de variables 
        11. *Tangente*: relación tangencial respecto a una relación lineal del resto de variables 
        12. *Absoluto*: valor absoluto respecto a una relación lineal del resto de variables 
        13. *Truncar*: truncar respecto a una relación lineal del resto de variables 
        14. *Log10*: logarítmo en base 10 de una relación lineal del resto de variables 
        15. *Log1p*: logaritmo de una relación lineal del resto de variables 
        16. *Log2*: logaritmo en base 2 de una relación lineal del resto de variables 
        17. *Ceil*: parte entera de una relación lineal del resto de variables 
    - **condiciones** : array con las condiciones. Valores posibles:
        1. indice + Menor/Mayor/Igual/Menor=/Mayor= + valor: comprueba que el valor de la columna correspondiente al indice sea menor/mayor/igual/menor o igual/mayor o igual que el valor
        2. indice1 + Menores/Mayores/Iguales/Menores=/Mayores= + indice2: comprueba que el valor de la columna correspondiente al indice1 sea menor/mayor/igual/menor o igual/mayor o igual que el valor de la columna correspondiente al indice2
        3. default: siempre se cumple
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    Nota: Debe haber tantas funciones como condiciones. Si se cumple la n-ésima condición, entonces el valor de la nueva columna se obtiene de aplicar la n-ésima función
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    func = funciones[0].split(",")
    cond = condiciones[0].split(",")
    f=list()
    c=list()

    for k in range(0,len(func)):
        f.append(elegir_funcion_multi(func[k]))

    for k in range(0,len(f)):
        c.append(elegir_condicion(cond[k]))

    df1 = objetivo_condicional(df,columna,c,f)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación de datos obtenidos tras aplicar una función a una combinación lineal de las variables.
@app.post("/Variables/Funcional")
async def obtener_datos( funciones: str , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos generados añadiendole una columna a partir de una relación funcional respecto a las columnas ya existentes. Parámetros:
    - **funciones** : valores posibles:
        1. *Lineal*: relación lineal respecto al resto de las variables
        2. *Polinomica2*: relación polinómica de grado 2 respecto al resto de las variables
        3. *Polinomica3*: relación polinómica de grado 3 respecto al resto de las variables
        4. *Polinomica4*: relación polinómica de grado 4 respecto al resto de las variables
        5. *Exponencial*: relación exponencial respecto a una relación lineal del resto de variables 
        6. *Exponencial2*: relación exponencial de base 2 respecto a una relación lineal del resto de variables 
        7. *Log*: relación logarítmica respecto a una relación lineal del resto de variables 
        8. *Raiz*: relación radical respecto a una relación lineal del resto de variables 
        9. *Seno*: relación senoidal respecto a una relación lineal del resto de variables 
        10. *Coseno*: relación cosenoidal respecto a una relación lineal del resto de variables 
        11. *Tangente*: relación tangencial respecto a una relación lineal del resto de variables 
        12. *Absoluto*: valor absoluto respecto a una relación lineal del resto de variables 
        13. *Truncar*: truncar respecto a una relación lineal del resto de variables 
        14. *Log10*: logarítmo en base 10 de una relación lineal del resto de variables 
        15. *Log1p*: logaritmo de una relación lineal del resto de variables 
        16. *Log2*: logaritmo en base 2 de una relación lineal del resto de variables 
        17. *Ceil*: parte entera de una relación lineal del resto de variables 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    f = elegir_funcion_multi(funciones)
    df1 = objetivo_funcional(df,columna,f)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-funcional.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar una función a una combinación lineal de las variables.
@app.post("/Plot/Variables/Funcional")
async def obtener_grafica( funciones: str , indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de una relación funcional respecto a las columnas ya existentes. Parámetros:
    - **funciones** : valores posibles:
        1. *Lineal*: relación lineal respecto al resto de las variables
        2. *Polinomica2*: relación polinómica de grado 2 respecto al resto de las variables
        3. *Polinomica3*: relación polinómica de grado 3 respecto al resto de las variables
        4. *Polinomica4*: relación polinómica de grado 4 respecto al resto de las variables
        5. *Exponencial*: relación exponencial respecto a una relación lineal del resto de variables 
        6. *Exponencial2*: relación exponencial de base 2 respecto a una relación lineal del resto de variables 
        7. *Log*: relación logarítmica respecto a una relación lineal del resto de variables 
        8. *Raiz*: relación radical respecto a una relación lineal del resto de variables 
        9. *Seno*: relación senoidal respecto a una relación lineal del resto de variables 
        10. *Coseno*: relación cosenoidal respecto a una relación lineal del resto de variables 
        11. *Tangente*: relación tangencial respecto a una relación lineal del resto de variables 
        12. *Absoluto*: valor absoluto respecto a una relación lineal del resto de variables 
        13. *Truncar*: truncar respecto a una relación lineal del resto de variables 
        14. *Log10*: logarítmo en base 10 de una relación lineal del resto de variables 
        15. *Log1p*: logaritmo de una relación lineal del resto de variables 
        16. *Log2*: logaritmo en base 2 de una relación lineal del resto de variables 
        17. *Ceil*: parte entera de una relación lineal del resto de variables 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    f = elegir_funcion_multi(funciones)
    df1 = objetivo_funcional(df,columna,f)    
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos tras aplicar Principal Component Analysis sobre las variables
@app.post("/Variables/PCA")
async def obtener_datos( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos generados añadiendole una nueva columna con la primera componente principal tras aplicar estandarización sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_PCA(df,columna)
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-PCA.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar Principal Component Analysis sobre las variables
@app.post("/Plot/Variables/PCA")
async def obtener_grafica( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una nueva columna con la primera componente principal tras aplicar estandarización sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """ 
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = objetivo_PCA(df,columna)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación de datos obtenidos tras aplicar la matriz de correlación para generar una nueva variable.
@app.post("/Variables/Correlacion")
async def obtener_datos( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos generados añadiendole una columna a partir de aplicar la matriz de correlación sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """ 
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = objetivo_correlacion(df,columna)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-corr.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar la matriz de correlación para generar una nueva variable
@app.post("/Plot/Variables/Correlacion")
async def obtener_grafica( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de aplicar la matriz de correlación sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """ 
    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = objetivo_correlacion(df,columna)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación de datos obtenidos tras aplicar la matriz de correlación para generar una nueva variable.
@app.post("/Variables/Covarianza")
async def obtener_datos( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos generados añadiendole una columna a partir de aplicar la matriz de covarianza sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """ 
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df1 = objetivo_covarianza(df,columna)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=objetivo-cov.csv"
    return response 

# Gráfica de datos obtenidos tras aplicar la matriz de correlación para generar una nueva variable
@app.post("/Plot/Variables/Covarianza")
async def obtener_grafica( indice:str, columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados añadiendole una columna a partir de aplicar la matriz de covarianza sobre las variables. Parámetros: 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **columna** : nombre de la nueva columna generada 
    - **file** : csv con los datos multivariable
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = objetivo_covarianza(df,columna)  
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Gráfica con datos obtenidos a partir de una interpolación lineal/cúbica y tomando como final el minimo valor
@app.post("/Aumentar/Interpolacion")
async def obtener_datos(tipo_interpolacion : str, tipo_array:str,num: int,  freq:str, indice:str, s:int=1,file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados aplicando interpolación matemática. Parámetros: 
    - **tipo_interpolacion**: tipo de interpolación a aplicar --> ‘linear’, ‘nearest’, ‘nearest-up’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’, or ‘next’. ‘zero’, ‘slinear’, ‘quadratic’ and ‘cubic’
    - **tipo_array**: inicio y fin del array tomado para interpolar --> min-max (desde el valor mínimo al máximo o viceversa), normal (desde el primero al último). Otro valor posible es spline --> interpolación tipo spline.
    - **num**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **s** : parámetro interpolación spline
    - **file** : csv con los datos 
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    if tipo_array=="min-max":
        df1 = interpolacion_min_max(df,tipo_interpolacion,num,freq)
    elif tipo_array == "normal":
        df1 = interpolacion_normal(df,tipo_interpolacion,num,freq)
    elif tipo_array == "spline":
        df1 = interpolacion_spline(df,tipo_interpolacion,num,freq,s)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-interpolacion.csv"
    return response 

# Creación csv con datos obtenidos a partir de una interpolación lineal/cúbica y tomando como final el mínimo valor
@app.post("/Plot/Aumentar/Interpolacion")
async def obtener_grafica(tipo_interpolacion : str, tipo_array:str, num: int, freq:str, indice:str,s:int=0, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados que han sido aumentados aplicando interpolación matemática. Parámetros: 
    - **tipo_interpolacion**: tipo de interpolación a aplicar --> linear, cubic, quadratic
    - **tipo_array**: inicio y fin del array tomado para interpolar --> min-max (desde el valor mínimo al máximo o viceversa), normal (desde el primero al último). Otro valor posible es spline --> interpolación tipo spline.
    - **num**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **s** : parámetro interpolación spline
    - **file** : csv con los datos 
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    if tipo_array=="min-max":
        df1 = interpolacion_min_max(df,tipo_interpolacion,num,freq)
    elif tipo_array == "normal":
        df1 = interpolacion_normal(df,tipo_interpolacion,num,freq)
    elif tipo_array == "spline":
        df1 = interpolacion_spline(df,tipo_interpolacion,num,freq,s)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación csv con datos obtenidos a partir de una interpolación a través del punto medio de los datos previos y posteriores
@app.post("/Aumentar/Interpolacion/Medio")
async def obtener_datos(freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados aplicando el tipo de interpolación punto medio. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = punto_medio(df,freq)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-interpolacion-medio.csv"
    return response 

# Gráfica de datos obtenidos con una interpolación a través del punto medio de los datos previos y posteriores
@app.post("/Plot/Aumentar/Interpolacion/Medio")
async def obtener_grafica(freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados que han sido aumentados aplicando el tipo de interpolación punto medio. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = punto_medio(df,freq)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Random Sampling
# Barajamos los datos de forma aleatoria 
def sampling(df,size,freq):
    np.random.seed(1)
    indice = series_periodos(df.index[0],size+df.shape[0],freq)
    for x in df.columns:
        data = df[x]
        sampled_data = np.random.choice(data, size=size, replace=True) + np.random.normal(0, 0.5, size)
        if x == df.columns[0]:
            df_sampling=pd.DataFrame(data=np.concatenate((data,sampled_data)),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,sampled_data)),index=indice,columns=[x])
            df_sampling= df_sampling.join(df_new, how="outer")
    return df_sampling

# Creación csv con los datos obtenidos mediante sampling 
@app.post("/Aumentar/Sampling")
async def obtener_datos(size:int,freq:str, indice:str, file: UploadFile = File(...)) :   
    """
    Devuelve un csv con los datos aumentados mediante selección aleatoria y añadir ruido. Parámetros:
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = sampling(df,size,freq)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-sampling.csv"
    return response 

# Gráfica con los datos obtenidos mediante sampling 
@app.post("/Plot/Aumentar/Sampling")
async def obtener_grafica(size:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados que han sido aumentados mediante selección aleatoria y añadir ruido. Parámetros:
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = sampling(df,size,freq)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")



# Creación csv de datos obtenidos con una distribución normal con la media y desv típica de los datos
@app.post("/Aumentar/Normal")
async def obtener_datos(size:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados obteniendo la media y la desviación de los datos existentes y generando los nuevos datos con una distribución normal con estos parámetros. Parámetros:
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = normal(df,freq,size)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-normal.csv"
    return response 

# Gráfica de los datos obtenidos con una distribución normal con la media y desv típica de los datos
@app.post("/Plot/Aumentar/Normal")
async def obtener_grafica(size:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una gráfica con los datos graficados que han sido aumentados obteniendo la media y la desviación de los datos existentes y generando los nuevos datos con una distribución normal con estos parámetros. Parámetros:
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = normal(df,freq,size)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv de datos obtenidos con box muller
@app.post("/Aumentar/Muller")
async def obtener_datos(size:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados obteniendo la media y la desviación de los datos existentes y generando los nuevos datos a través de la fórmula: media + z1 * desv_tipica donde z1 =  (-2 np.log(u1))<sup>1/2</sup> cos(2 π u2) donde u1, u2 son valores entre 0 e 1. Parámetros:
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = box_muller(df,freq,size)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-muller.csv"
    return response 

# Gráfica de datos obtenidos con box muller
@app.post("/Plot/Aumentar/Muller")
async def obtener_grafica(size:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados que han sido aumentados obteniendo la media y la desviación de los datos existentes y generando los nuevos datos a través de la fórmula: media + z1 * desv_tipica donde z1 =  (-2 np.log(u1))<sup>1/2</sup> cos(2 π u2) donde u1, u2 son valores entre 0 e 1. Parámetros
    - **size**: número de datos a crear 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = box_muller(df,freq,size)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv con algunos datos duplicados y con ruido
@app.post("/Aumentar/Duplicado")
async def obtener_datos(freq:str,duplication_factor:float, perturbation_std: float, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados tras duplicar algunos de los datos e introducir cierto ruido. Parámetros:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **duplication_factor**: factor entre 0 y 1, si el valor aleatorio generado es menor que él entonces se duplica el dato
    - **perturbacion_std**: desviación típica del ruido 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """ 
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = duplicados(df,freq,duplication_factor,perturbation_std)
    
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-duplicado.csv"
    return response 

# Gráfica con algunos datos duplicados y con ruido
@app.post("/Plot/Aumentar/Duplicado")
async def obtener_grafica(freq:str,duplication_factor:float, perturbation_std: float, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras duplicar algunos de los datos e introducir cierto ruido. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **duplication_factor**: factor entre 0 y 1, si el valor aleatorio generado es menor que él entonces se duplica el dato
    - **perturbacion_std**: desviación típica del ruido 
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """ 
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = duplicados(df,freq,duplication_factor,perturbation_std)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv con datos obtenidos como combinación lineal de los previos
@app.post("/Aumentar/Comb_lineal")
async def obtener_datos(freq:str,size:int, indice:str,window_size:int, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados mediante combinación lineal de los datos previos. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **size**: número de datos a generar
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **window_size**: tamaño de ventana, número de datos previos tomados para realizar la combinación lineal
    - **file** : csv con los datos 
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = agregar_comb(df,freq,size,window_size)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-comb-lineal.csv"
    return response 

# Gráfica con los datos obtenidos como combinación lineal de los datos previos
@app.post("/Plot/Aumentar/Comb_lineal")
async def obtener_grafica(freq:str,size:int, indice:str,window_size:int, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados mediante combinación lineal de los datos previos. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **size**: número de datos a generar
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **window_size**: tamaño de ventana, número de datos previos tomados para realizar la combinación lineal
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = agregar_comb(df,freq,size,window_size)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación csv con los datos trasladados
@app.post("/Aumentar/Traslacion")
async def obtener_datos(shift:float, freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados mediante una traslación de los datos previos. Parámetros: 
    - **shift**: desplazamiento hacia arriba/abajo de los datos
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = traslacion(df,shift,freq)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-traslacion.csv"
    return response 

# Gráfica con los datos trasladados 
@app.post("/Plot/Aumentar/Traslacion")
async def obtener_grafica(shift:float, freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados mediante una traslación de los datos previos. Parámetros: 
    - **shift**: desplazamiento hacia arriba/abajo de los datos
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = traslacion(df,shift,freq)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")
    

# Creación csv con datos con ruido armónico
@app.post("/Aumentar/Armonico")
async def obtener_datos(freq:str, indice:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados mediante adición de ruido armónico. Parámetros: 
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **size** : número de datos a generar
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = add_harmonic_noise(df,freq, size)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-ruido-harmonico.csv"
    return response 

# Gráfica obtenida tras aplicar ruido armónico 
@app.post("/Plot/Aumentar/Armonico")
async def obtener_grafica(freq:str, indice:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos aumentados mediante la técnica de adición de ruido armónico. Parámetros: 
    - **shift**: desplazamiento hacia arriba/abajo de los datos
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = add_harmonic_noise(df,freq,size)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")



# Creación csv con los datos obtenidos al escalar los datos
@app.post("/Aumentar/Escalado")
async def obtener_datos(factor:float, freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados mediante un escalado de los datos previos. Parámetros: 
    - **factor**: factor por el que se multiplican los datos
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = escalado(df,freq,factor)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-escalado.csv"
    return response 

# Gráfica de los datos obtenidos tras realizar un escalado de los datos 
@app.post("/Plot/Aumentar/Escalado")
async def obtener_grafica(factor:float, freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos aumentados mediante un escalado de los datos previos. Parámetros: 
    - **factor**: factor por el que se multiplican los datos
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    # Leer el archivo CSV en un DataFrame de pandas
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = escalado(df,freq,factor)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv con los datos obtenidos de aplicar la técnica de aumentación de datos 
@app.post("/Aumentar/Matematica")
async def obtener_datos(funcion:str, freq:str, indice:str,factor : Union[float,None] = 1, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados tras aplicar alguna operación matemática. Parámetros:
    - **funcion**: función matemática que se aplica. Opciones:
        1. sqrt --> raíz cuadrada
        2. log --> logaritmo 
        3. exp --> exponencial
        4. sin --> seno
        5. cos --> coseno
        6. trig --> seno + coseno
        7. sigmoide --> 1 / (1 + *e*<sup>-x</sup>)
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **factor** : factor por el que se dividen los datos en el caso de la exponencial para evitar que salgan valores muy altos
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = agregar_matematica(df,freq,funcion,factor)
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-matematica.csv"
    return response 

# Gráfica de la técnica de aumentación de datos mediante transformaciones matemáticas
@app.post("/Plot/Aumentar/Matematica")
async def obtener_grafica(funcion:str, freq:str, indice:str,factor : Union[float,None] = 1, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados al aplicar alguna operación matemática. Parámetros:
    - **funcion**: función matemática que se aplica. Opciones:
        1. sqrt --> raíz cuadrada
        2. log --> logaritmo 
        3. exp --> exponencial
        4. sin --> seno
        5. cos --> coseno
        6. trig --> seno + coseno
        7. sigmoide --> 1 / (1 + *e*<sup>-x</sup>)
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **factor** : factor por el que se dividen los datos en el caso de la exponencial para evitar que salgan valores muy altos
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = agregar_matematica(df,freq,funcion,factor)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Creación csv con los datos obtenidos de aplicar la técnica de aumentación de datos 
@app.post("/Aumentar/Estadistica")
async def obtener_datos(tipo:int, num:int,freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados por medidas estadísticas. Parámetros:
    - **tipo**: medida estadística con la que se aumentan los datos. Opciones:
        1. Media
        2. Mediana
        3. Moda
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num** : número de datos a generar
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = estadist(df,freq,num,tipo)
        
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df1.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=aumentar-matematica.csv"
    
    return response 

# Gráfica de la técnica de aumentación de datos mediante transformaciones matemáticas
@app.post("/Plot/Aumentar/Estadistica")
async def obtener_grafica(tipo:int,num:int, freq:str, indice:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados por medidas estadísticas. Parámetros:
    - **tipo**: medida estadística con la que se aumentan los datos. Opciones:
        1. Media
        2. Mediana
        3. Moda
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **num** : número de datos a generar
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")
    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df1 = estadist(df,freq,num,tipo)
    plot_df(df1)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Creación csv con la técnica de descomposición
@app.post("/Aumentar/Descomponer")
async def obtener_datos(indice:str,freq:str, size:int,tipo:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados a través de la descomposición de la serie. Parámetros:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**:
        1. additive: realiza una descomposición aditiva de la serie en tendencia y estacionalidad. Usa esto para predecir los siguientes valores
        2. multiplicative: realiza una descomposición multiplicativa de la serie en tendencia y estacionalidad. Usa esto para predecir los siguientes valores
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    df_desc= descomp(df,size,freq,tipo)       
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df_desc.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=descomposicion.csv"
    return response 

# Gráfrica técnica de descomposición
@app.post("/Plot/Aumentar/Descomponer")
async def obtener_grafica( indice:str,freq:str,size:int,tipo:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados a través de la descomposición de la serie. Parámetros:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **tipo**:
        1. additive: realiza una descomposición aditiva de la serie en tendencia y estacionalidad. Usa esto para predecir los siguientes valores
        2. multiplicative: realiza una descomposición multiplicativa de la serie en tendencia y estacionalidad. Usa esto para predecir los siguientes valores
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df_desc= descomp(df,size,freq,tipo)       

    plot_df(df_desc)
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


@app.post("/Datos/Sarimax")
async def obtener_datos(indice:str,freq:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados utilizando la predicción del modelo Sarimax. Parámetros:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        prediccion = prediccion_sarimax(df,df,x,size)[:size]
        if x == df.columns[0]:
            df_sarimax=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_sarimax= df_sarimax.join(df_new, how="outer")
    stream = io.StringIO()
    df_sarimax.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=prediccion-sarimax.csv"
    return response 


@app.post("/Plot/Datos/Sarimax")
async def obtener_grafica(indice:str,freq:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve una gráfica con los datos graficados tras ser aumentados utilizando la predicción del modelo Sarimax. Parámetros:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        prediccion = prediccion_sarimax(df,df,x,size)[:size]
        if x == df.columns[0]:
            df_sarimax=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_sarimax= df_sarimax.join(df_new, how="outer")

    plt.figure()
    df_sarimax.plot(title="Predicciones Sarimax",figsize=(13,5))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio modelo Sarimax
@app.post("/Error/Sarimax")
async def obtener_error(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre la predicción del modelo sarimax y los valores reales de test (20% finales):
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    return {error_sarimax(df[:train],df[train:], df.columns[0]) }

# Gráfica modelo sarimax
@app.post("/Plot/Sarimax")
async def obtener_grafica_error(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos del test (20% últimos) y los datos de predicción de Sarimax graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    train = int(df.shape[0]*0.8)
    df_test = df[train:]
    predicciones_m1=prediccion_sarimax(df,df[:train], df.columns[0],df_test.shape[0])[:df_test.shape[0]]
    result = pd.merge(df_test, predicciones_m1, left_index=True, right_index=True)
    plt.figure()
    result.plot(title="Predicciones Sarimax",figsize=(13,5))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


@app.post("/Datos/ForecasterAutoreg")
async def obtener_datos(indice:str,freq:str,size:int,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve un csv con los datos aumentados mediante la predicción del modelo de forecasting autorregresivo con regresor Random Forest:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **size**: número de datos a generar
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        if regresor=='RF':
            #Forecaster con Random Forest
            forecaster = ForecasterAutoreg(
                    regressor = RandomForestRegressor(random_state=123),
                    lags      = 10
                )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
            }
            
        elif regresor=='GB':
            
            # Forecaster con Gradient Boosting
            forecaster = ForecasterAutoreg(
                                regressor = GradientBoostingRegressor(random_state=123),
                                lags      = 10
                            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                    'n_estimators': [100, 200, 300],
                    'learning_rate': [0.01, 0.1, 1.0],
                    'max_depth': [3, 5, 7],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor=='ET':
            # Forecaster con ExtraTree
            forecaster = ForecasterAutoreg(
                                regressor = ExtraTreesRegressor(random_state=123),
                                lags      = 10
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
            }
        elif regresor=='DT':
            # Forecaster con DT
            forecaster = ForecasterAutoreg(
                                regressor = DecisionTreeRegressor(random_state=123),
                                lags      = 10
                            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                    'max_depth': [None, 5, 10, 20, 30],
                    'min_samples_split': [2, 5, 10, 15],
                    'min_samples_leaf': [1, 2, 5, 10],
                    'max_features': [None, 'sqrt', 'log2']
                }  
        elif regresor =='RIDGE':
            #Forecaster con Ridge
            forecaster = ForecasterAutoreg(
                            regressor     = Ridge(random_state=123),
                            transformer_y = StandardScaler(),
                            lags          = 5
            )

            # Valores candidatos de lags
            lags_grid = [5, 12, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {'alpha': np.logspace(-5, 5, 10)}
            
        prediccion = prediccion_backtesting_forecasterAutoreg(df,x,size,180,param_grid,lags_grid,forecaster)
        if x == df.columns[0]:
            df_rf=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_rf= df_rf.join(df_new, how="outer")
            
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df_rf.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=prediccion-Forecaster-"+regresor+".csv"
    return response 

@app.post("/Plot/Datos/ForecasterAutoreg")
async def obtener_grafica(indice:str,freq:str,size:int,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados con la predicción del modelo de forecasting autorregresivo con regresor Random Forest:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **size**: número de datos a generar
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        if regresor=='RF':
            #Forecaster con Random Forest
            forecaster = ForecasterAutoreg(
                    regressor = RandomForestRegressor(random_state=123),
                    lags      = 10
                )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
            }
            
        elif regresor=='GB':
            
            # Forecaster con Gradient Boosting
            forecaster = ForecasterAutoreg(
                                regressor = GradientBoostingRegressor(random_state=123),
                                lags      = 10
                            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                    'n_estimators': [100, 200, 300],
                    'learning_rate': [0.01, 0.1, 1.0],
                    'max_depth': [3, 5, 7],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor=='ET':
            # Forecaster con ExtraTree
            forecaster = ForecasterAutoreg(
                                regressor = ExtraTreesRegressor(random_state=123),
                                lags      = 10
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
            } 
        elif regresor=='DT':
            # Forecaster con DT
            forecaster = ForecasterAutoreg(
                                regressor = DecisionTreeRegressor(random_state=123),
                                lags      = 10
                            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                    'max_depth': [None, 5, 10, 20, 30],
                    'min_samples_split': [2, 5, 10, 15],
                    'min_samples_leaf': [1, 2, 5, 10],
                    'max_features': [None, 'sqrt', 'log2']
                } 
        elif regresor =='RIDGE':
            #Forecaster con Ridge
            forecaster = ForecasterAutoreg(
                            regressor     = Ridge(random_state=123),
                            transformer_y = StandardScaler(),
                            lags          = 5
            )

            # Valores candidatos de lags
            lags_grid = [5, 12, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {'alpha': np.logspace(-5, 5, 10)}
        prediccion = prediccion_backtesting_forecasterAutoreg(df,x,size,180,param_grid,lags_grid,forecaster)
        if x == df.columns[0]:
            df_rf=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_rf= df_rf.join(df_new, how="outer")
            
    plt.figure()
    df_rf.plot(title="Predicciones Modelo Forecaster Autorregresivo "+ regresor,figsize=(13,5))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio del modelo autorregresivo Random Forest
@app.post("/Error/ForecasterAutoreg")
async def obtener_error(indice:str,freq:str,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (el 20% final) y la predicción del modelo modelo de forecasting autorregresivo con regresor Random Forest:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    test = df.shape[0]-train
    if regresor=='RF':
        #Forecaster con Random Forest
        forecaster = ForecasterAutoreg(
                    regressor = RandomForestRegressor(random_state=123),
                    lags      = 10
                )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
        }
            
    elif regresor=='GB':
            
        # Forecaster con Gradient Boosting
        forecaster = ForecasterAutoreg(
                                regressor = GradientBoostingRegressor(random_state=123),
                                lags      = 10
                            )
        # Valores candidatos de lags
        lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                    'n_estimators': [100, 200, 300],
                    'learning_rate': [0.01, 0.1, 1.0],
                    'max_depth': [3, 5, 7],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor=='ET':
        # Forecaster con ExtraTree
        forecaster = ForecasterAutoreg(
                                regressor = ExtraTreesRegressor(random_state=123),
                                lags      = 10
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
        } 
    elif regresor=='DT':
        # Forecaster con DT
        forecaster = ForecasterAutoreg(
            regressor = DecisionTreeRegressor(random_state=123),
            lags      = 10
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'max_depth': [None, 5, 10, 20, 30],
            'min_samples_split': [2, 5, 10, 15],
            'min_samples_leaf': [1, 2, 5, 10],
            'max_features': [None, 'sqrt', 'log2']
        }
    elif regresor =='RIDGE':
            #Forecaster con Ridge
            forecaster = ForecasterAutoreg(
                            regressor     = Ridge(random_state=123),
                            transformer_y = StandardScaler(),
                            lags          = 5
                        )

            # Valores candidatos de lags
            lags_grid = [5, 12, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {'alpha': np.logspace(-5, 5, 10)} 
        
    return {error_backtesting_forecasterAutoreg(df[:train],df[train:],'Valor',test,180,param_grid,lags_grid,forecaster) }

# Gráfica del modelo autorregresivo Random Forest
@app.post("/Plot/ForecasterAutoreg")
async def obtener_grafica_error(indice:str,freq:str,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (el 20% final) y la predicción del modelo de forecasting autorregresivo con regresor Random Forest graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    df_test = df[train:]
    if regresor=='RF':
        #Forecaster con Random Forest
        forecaster = ForecasterAutoreg(
                    regressor = RandomForestRegressor(random_state=123),
                    lags      = 10
                )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
        }
            
    elif regresor=='GB':
            
        # Forecaster con Gradient Boosting
        forecaster = ForecasterAutoreg(
                                regressor = GradientBoostingRegressor(random_state=123),
                                lags      = 10
                            )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                    'n_estimators': [100, 200, 300],
                    'learning_rate': [0.01, 0.1, 1.0],
                    'max_depth': [3, 5, 7],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor=='ET':
        # Forecaster con ExtraTree
        forecaster = ForecasterAutoreg(
                                regressor = ExtraTreesRegressor(random_state=123),
                                lags      = 10
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
                    'n_estimators': [100, 200, 500],
                    'max_depth': [ 10, 20, 30],
                    'min_samples_split': [2, 5, 10],
                    'min_samples_leaf': [1, 2, 4],
                    'max_features': [None, 'sqrt', 'log2'],
        } 
    elif regresor=='DT':
        # Forecaster con DT
        forecaster = ForecasterAutoreg(
            regressor = DecisionTreeRegressor(random_state=123),
            lags      = 10
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'max_depth': [None, 5, 10, 20, 30],
            'min_samples_split': [2, 5, 10, 15],
            'min_samples_leaf': [1, 2, 5, 10],
            'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor =='RIDGE':
        #Forecaster con Ridge
        forecaster = ForecasterAutoreg(
             regressor     = Ridge(random_state=123),
            transformer_y = StandardScaler(),
            lags          = 5
        )

        # Valores candidatos de lags
        lags_grid = [5, 12, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {'alpha': np.logspace(-5, 5, 10)}
    predicciones_m1 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df_test.shape[0],180,param_grid,lags_grid,forecaster)
    result = pd.merge(df_test, predicciones_m1, left_index=True, right_index=True)
    plt.figure()
    result.plot(title="Predicciones Modelo Forecaster Autorregresivo",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

@app.post("/Datos/AutoregDirect")
async def obtener_datos(indice:str,freq:str,size:int,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve el csv con los datos aumentados usando la predicción del modelo de forecasting autorregresivo con regresor lineal con penalización Ridge:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).

    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq

    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        if regresor=='RF':
            #Forecaster con Random Forest
            forecaster = ForecasterAutoregDirect(
                        regressor = RandomForestRegressor(random_state=123),
                        lags      = 10,
                        steps     = size
                    )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                        'n_estimators': [100, 200, 500],
                        'max_depth': [ 10, 20, 30],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2'],
            }
                
        elif regresor=='GB':
                
            # Forecaster con Gradient Boosting
            forecaster = ForecasterAutoregDirect(
                                    regressor = GradientBoostingRegressor(random_state=123),
                                    lags      = 10,
                                    steps     = size
                                )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                        'n_estimators': [100, 200, 300],
                        'learning_rate': [0.01, 0.1, 1.0],
                        'max_depth': [3, 5, 7],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor=='ET':
            # Forecaster con ExtraTree
            forecaster = ForecasterAutoregDirect(
                                    regressor = ExtraTreesRegressor(random_state=123),
                                    lags      = 10,
                                    steps     = size
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                        'n_estimators': [100, 200, 500],
                        'max_depth': [ 10, 20, 30],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2'],
            } 
        elif regresor=='DT':
            # Forecaster con DT
            forecaster = ForecasterAutoregDirect(
                regressor = DecisionTreeRegressor(random_state=123),
                lags      = 10,
                steps     = size
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                'max_depth': [None, 5, 10, 20, 30],
                'min_samples_split': [2, 5, 10, 15],
                'min_samples_leaf': [1, 2, 5, 10],
                'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor =='RIDGE':
            #Forecaster con Ridge
            forecaster = ForecasterAutoregDirect(
                regressor     = Ridge(random_state=123),
                transformer_y = StandardScaler(),
                steps         = size,
                lags          = 5
            )

            # Valores candidatos de lags
            lags_grid = [5, 12, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {'alpha': np.logspace(-5, 5, 10)}
        prediccion = predicciones_backtesting_forecasterAutoregDirect(df,x,size,param_grid,lags_grid,forecaster)
        if x == df.columns[0]:
            df_ridge=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_ridge= df_ridge.join(df_new, how="outer")
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df_ridge.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=prediccion-ForecasterRidge.csv"
    return response 

@app.post("/Plot/Datos/AutoregDirect")
async def obtener_grafica(indice:str,freq:str,size:int,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos graficados tras ser aumentados usando la predicción del modelo de forecasting autorregresivo con regresor lineal con penalización Ridge:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).

    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        if regresor=='RF':
            #Forecaster con Random Forest
            forecaster = ForecasterAutoregDirect(
                        regressor = RandomForestRegressor(random_state=123),
                        lags      = 10,
                        steps     = size
                    )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                        'n_estimators': [100, 200, 500],
                        'max_depth': [ 10, 20, 30],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2'],
            }
                
        elif regresor=='GB':
                
            # Forecaster con Gradient Boosting
            forecaster = ForecasterAutoregDirect(
                                    regressor = GradientBoostingRegressor(random_state=123),
                                    lags      = 10,
                                    steps     = size
                                )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {
                        'n_estimators': [100, 200, 300],
                        'learning_rate': [0.01, 0.1, 1.0],
                        'max_depth': [3, 5, 7],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor=='ET':
            # Forecaster con ExtraTree
            forecaster = ForecasterAutoregDirect(
                                    regressor = ExtraTreesRegressor(random_state=123),
                                    lags      = 10,
                                    steps     = size
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                        'n_estimators': [100, 200, 500],
                        'max_depth': [ 10, 20, 30],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2'],
            } 
        elif regresor=='DT':
            # Forecaster con DT
            forecaster = ForecasterAutoregDirect(
                regressor = DecisionTreeRegressor(random_state=123),
                lags      = 10,
                steps     = size
            )
            # Valores candidatos de lags
            lags_grid = [10, 20]

            param_grid = {
                'max_depth': [None, 5, 10, 20, 30],
                'min_samples_split': [2, 5, 10, 15],
                'min_samples_leaf': [1, 2, 5, 10],
                'max_features': [None, 'sqrt', 'log2']
            } 
        elif regresor =='RIDGE':
            #Forecaster con Ridge
            forecaster = ForecasterAutoregDirect(
                regressor     = Ridge(random_state=123),
                transformer_y = StandardScaler(),
                steps         = size,
                lags          = 5
            )

            # Valores candidatos de lags
            lags_grid = [5, 12, 20]

            # Valores candidatos de hiperparámetros del regresor
            param_grid = {'alpha': np.logspace(-5, 5, 10)}
        prediccion = predicciones_backtesting_forecasterAutoregDirect(df,x,size,param_grid,lags_grid,forecaster)
        if x == df.columns[0]:
            df_ridge=pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion.values.reshape(-1))),index=indice,columns=[x])
            df_ridge= df_ridge.join(df_new, how="outer")
    plt.figure()
    df_ridge.plot(title="Predicciones Modelo Autorregresivo Ridge",figsize=(13,5))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático del modelo autorregresivo Ridge
@app.post("/Error/AutoregDirect")
async def obtener_error(indice:str,freq:str,regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y la predicción del modelo de forecasting autorregresivo con regresor lineal con penalización Ridge:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).

    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    if regresor=='RF':
        #Forecaster con Random Forest
        forecaster = ForecasterAutoregDirect(
            regressor = RandomForestRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
            'n_estimators': [100, 200, 500],
            'max_depth': [ 10, 20, 30],
            'min_samples_split': [2, 5, 10],
            'min_samples_leaf': [1, 2, 4],
            'max_features': [None, 'sqrt', 'log2'],
        }
                
    elif regresor=='GB':
                
        # Forecaster con Gradient Boosting
        forecaster = ForecasterAutoregDirect(
                regressor = GradientBoostingRegressor(random_state=123),
                lags      = 10,
                steps     = df[train:].shape[0]
        )
            # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                        'n_estimators': [100, 200, 300],
                        'learning_rate': [0.01, 0.1, 1.0],
                        'max_depth': [3, 5, 7],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor=='ET':
        # Forecaster con ExtraTree
        forecaster = ForecasterAutoregDirect(
            regressor = ExtraTreesRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'n_estimators': [100, 200, 500],
            'max_depth': [ 10, 20, 30],
            'min_samples_split': [2, 5, 10],
            'min_samples_leaf': [1, 2, 4],
            'max_features': [None, 'sqrt', 'log2'],
        } 
    elif regresor=='DT':
        # Forecaster con DT
        forecaster = ForecasterAutoregDirect(
            regressor = DecisionTreeRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
            # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'max_depth': [None, 5, 10, 20, 30],
            'min_samples_split': [2, 5, 10, 15],
            'min_samples_leaf': [1, 2, 5, 10],
            'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor =='RIDGE':
        #Forecaster con Ridge
        forecaster = ForecasterAutoregDirect(
            regressor     = Ridge(random_state=123),
            transformer_y = StandardScaler(),
            steps         = df[train:].shape[0],
            lags          = 5
        )

        # Valores candidatos de lags
        lags_grid = [5, 12, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {'alpha': np.logspace(-5, 5, 10)}
    return {error_backtesting_forecasterAutoregDirect(df[:train], df[train:],df[train:].shape[0],param_grid,lags_grid,forecaster) }

# Gráfica del modelo autorregresivo Ridge
@app.post("/Plot/AutoregDirect")
async def obtener_grafica_error(indice:str,freq:str, regresor:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos por el modelo modelo de forecasting autorregresivo con regresor lineal con penalización Ridge:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **regresor**: modelo regresor utilizado. Opciones: regresor lineal con penalización Ridge(RIDGE), Random Forest(RF), Decision Tree(DT), Extra Tree (ET) o Gradient Boosting (GB).

    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    train = int(df.shape[0]*0.8)
    df_test = df[train:]
    if regresor=='RF':
        #Forecaster con Random Forest
        forecaster = ForecasterAutoregDirect(
            regressor = RandomForestRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
            'n_estimators': [100, 200, 500],
            'max_depth': [ 10, 20, 30],
            'min_samples_split': [2, 5, 10],
            'min_samples_leaf': [1, 2, 4],
            'max_features': [None, 'sqrt', 'log2'],
        }
                
    elif regresor=='GB':
                
        # Forecaster con Gradient Boosting
        forecaster = ForecasterAutoregDirect(
                regressor = GradientBoostingRegressor(random_state=123),
                lags      = 10,
                steps     = df[train:].shape[0]
        )
            # Valores candidatos de lags
        lags_grid = [10, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {
                        'n_estimators': [100, 200, 300],
                        'learning_rate': [0.01, 0.1, 1.0],
                        'max_depth': [3, 5, 7],
                        'min_samples_split': [2, 5, 10],
                        'min_samples_leaf': [1, 2, 4],
                        'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor=='ET':
        # Forecaster con ExtraTree
        forecaster = ForecasterAutoregDirect(
            regressor = ExtraTreesRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
        # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'n_estimators': [100, 200, 500],
            'max_depth': [ 10, 20, 30],
            'min_samples_split': [2, 5, 10],
            'min_samples_leaf': [1, 2, 4],
            'max_features': [None, 'sqrt', 'log2'],
        } 
    elif regresor=='DT':
        # Forecaster con DT
        forecaster = ForecasterAutoregDirect(
            regressor = DecisionTreeRegressor(random_state=123),
            lags      = 10,
            steps     = df[train:].shape[0]
        )
            # Valores candidatos de lags
        lags_grid = [10, 20]

        param_grid = {
            'max_depth': [None, 5, 10, 20, 30],
            'min_samples_split': [2, 5, 10, 15],
            'min_samples_leaf': [1, 2, 5, 10],
            'max_features': [None, 'sqrt', 'log2']
        } 
    elif regresor =='RIDGE':
        #Forecaster con Ridge
        forecaster = ForecasterAutoregDirect(
            regressor     = Ridge(random_state=123),
            transformer_y = StandardScaler(),
            steps         = df[train:].shape[0],
            lags          = 5
        )

        # Valores candidatos de lags
        lags_grid = [5, 12, 20]

        # Valores candidatos de hiperparámetros del regresor
        param_grid = {'alpha': np.logspace(-5, 5, 10)}
    predicciones_m1=predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0], df[train:].shape[0],param_grid,lags_grid,forecaster)
    result = pd.merge(df_test, predicciones_m1, left_index=True, right_index=True)
    plt.figure()
    result.plot(title="Predicciones Modelo Autoregresivo Directo Ridge",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

@app.post("/Datos/Prophet")
async def obtener_datos(indice:str,freq:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve el csv con los datos aumentados usando el modelo Prophet:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        prediccion = pred_prophet_prediccion(df,x,size,freq)
        if x == df.columns[0]:
            df_prophet=pd.DataFrame(data=np.concatenate((data,prediccion)),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion)),index=indice,columns=[x])
            df_prophet= df_prophet.join(df_new, how="outer")
    # Convertir el DataFrame a un buffer de CSV
    stream = io.StringIO()
    df_prophet.to_csv(stream,index_label="Indice")
    stream.seek(0)

    # Devolver el archivo CSV como respuesta
    response = StreamingResponse(stream, media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=prediccion-pophet.csv"
    return response 

@app.post("/Plot/Datos/Prophet")
async def obtener_grafica(indice:str,freq:str,size:int, file: UploadFile = File(...)) :
    """
    Devuelve la imagen con los datos graficados tras ser aumentados usando la predicción Prophet:
    - **size**: número de datos a generar
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    indice = series_periodos(df.index[0],df.shape[0]+size,freq)
    for x in df.columns:
        data = df[x]
        prediccion = pred_prophet_prediccion(df,x,size,freq)
        if x == df.columns[0]:
            df_prophet=pd.DataFrame(data=np.concatenate((data,prediccion)),index=indice,columns=[x])
        else:
            df_new = pd.DataFrame(data=np.concatenate((data,prediccion)),index=indice,columns=[x])
            df_prophet= df_prophet.join(df_new, how="outer")
    plt.figure()
    df_prophet.plot(title="Predicciones Modelo Autorregresivo Prophet",figsize=(13,5))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio del modelo Prophet
@app.post("/Error/Prophet")
async def obtener_error(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y los datos predecidos con Prophet
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    return {error_prophet_prediccion(df[:train],df[train:],freq) }

# Gráfica del modelo de predicción Prophet
@app.post("/Plot/Prophet")
async def obtener_grafica_error(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20 % finales) y los datos predecidos usando el modelo Prophet:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    train = int(df.shape[0]*0.8)
    y_pred=pred_prophet_prediccion(df[:train],df[train:].shape[0],freq)
    plt.figure()
    y_true=df[train:].values
    result = pd.DataFrame({
        'Valores Reales': y_true.reshape(-1),
        'Predicciones': y_pred
    })
    result.index=df[train:].index
    result.plot(title="Predicciones Modelo Prophet",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Error cuadrático medio de todos los modelos de predicción 
@app.post("/Errores")
async def obtener_errores(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y todos los modelos estudiados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)
    
    #Forecaster con Random Forest
    forecasterRF = ForecasterAutoreg(
        regressor = RandomForestRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectRF = ForecasterAutoregDirect(
        regressor = RandomForestRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridRF = [10, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridRF = {
        'n_estimators': [100, 200, 500],
        'max_depth': [ 10, 20, 30],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2'],
    }
                
    # Forecaster con Gradient Boosting
    forecasterGB = ForecasterAutoreg(
            regressor = GradientBoostingRegressor(random_state=123),
            lags      = 10
    )
    
    forecasterDirectGB = ForecasterAutoregDirect(
            regressor = GradientBoostingRegressor(random_state=123),
            steps     = df[train:].shape[0],
            lags      = 10
    )
    # Valores candidatos de lags
    lags_gridGB = [10, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridGB = {
        'n_estimators': [100, 200, 300],
        'learning_rate': [0.01, 0.1, 1.0],
        'max_depth': [3, 5, 7],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2']
        } 
    
    # Forecaster con ExtraTree
    forecasterET = ForecasterAutoreg(
        regressor = ExtraTreesRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectET = ForecasterAutoregDirect(
        regressor = ExtraTreesRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridET = [10, 20]

    param_gridET = {
        'n_estimators': [100, 200, 500],
        'max_depth': [ 10, 20, 30],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2'],
    } 
   
    # Forecaster con DT
    forecasterDT = ForecasterAutoreg(
        regressor = DecisionTreeRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectDT = ForecasterAutoregDirect(
        regressor = DecisionTreeRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridDT = [10, 20]

    param_gridDT = {
        'max_depth': [None, 5, 10, 20, 30],
        'min_samples_split': [2, 5, 10, 15],
        'min_samples_leaf': [1, 2, 5, 10],
        'max_features': [None, 'sqrt', 'log2']
    } 
    
    #Forecaster con Ridge
    forecasterRidge = ForecasterAutoreg(
                    regressor     = Ridge(random_state=123),
                    transformer_y = StandardScaler(),
                    lags          = 5
                )
    forecasterDirectRidge = ForecasterAutoregDirect(
        regressor     = Ridge(random_state=123),
        transformer_y = StandardScaler(),
        steps         = df[train:].shape[0],
        lags          = 5
    )
    # Valores candidatos de lags
    lags_gridRidge = [5, 12, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridRidge = {'alpha': np.logspace(-5, 5, 10)}
    
    e_sarimax=error_sarimax(df,df[train:], df.columns[0])

    e_prophet = error_prophet_prediccion(df[:train],df[train:],freq)
    e_regRF = error_backtesting_forecasterAutoreg(df[:train],df[train:],df.columns[0],df[train:].shape[0],180,param_gridRF,lags_gridRF,forecasterRF)
    e_regDT = error_backtesting_forecasterAutoreg(df[:train],df[train:],df.columns[0],df[train:].shape[0],180,param_gridDT,lags_gridDT,forecasterDT)
    e_regGB = error_backtesting_forecasterAutoreg(df[:train],df[train:],df.columns[0],df[train:].shape[0],180,param_gridGB,lags_gridGB,forecasterGB)
    e_regET = error_backtesting_forecasterAutoreg(df[:train],df[train:],df.columns[0],df[train:].shape[0],180,param_gridET,lags_gridET,forecasterET)
    e_regRidge = error_backtesting_forecasterAutoreg(df[:train],df[train:],df.columns[0],df[train:].shape[0],180,param_gridRidge,lags_gridRidge,forecasterRidge)
    e_regRF_d = error_backtesting_forecasterAutoregDirect(df[:train],df[train:],df[train:].shape[0],param_gridRF,lags_gridRF,forecasterDirectRF)
    e_regDT_d = error_backtesting_forecasterAutoregDirect(df[:train],df[train:],df[train:].shape[0],param_gridDT,lags_gridDT,forecasterDirectDT)
    e_regGB_d = error_backtesting_forecasterAutoregDirect(df[:train],df[train:],df[train:].shape[0],param_gridGB,lags_gridGB,forecasterDirectGB)
    e_regET_d = error_backtesting_forecasterAutoregDirect(df[:train],df[train:],df[train:].shape[0],param_gridET,lags_gridET,forecasterDirectET)
    e_regRidge_d = error_backtesting_forecasterAutoregDirect(df[:train],df[train:],df[train:].shape[0],param_gridRidge,lags_gridRidge,forecasterDirectRidge)
    return {"Error predicción autorregresivo Sarimax": e_sarimax,
            "Error predicción forecaster con regresor lineal con penalización Ridge": e_regRidge,
            "Error predicción forecaster con regresor Decision Tree": e_regDT,
            "Error predicción forecaster con regresor Random Forest": e_regRF,
            "Error predicción forecaster con regresor Gradient Boosting": e_regGB,
            "Error predicción forecaster con regresor Extra Tree": e_regET,
            "Error predicción forecaster directo con regresor lineal con penalización Ridge": e_regRidge_d,
            "Error predicción forecaster directo con regresor Decision Tree": e_regDT_d,
            "Error predicción forecaster directo con regresor Random Forest": e_regRF_d,
            "Error predicción forecaster directo con regresor Gradient Boosting": e_regGB_d,
            "Error predicción forecaster directo con regresor Extra Tree": e_regET_d,
            "Error predicción prophet": e_prophet}
    
# Gráfica de los valores reales vs los valores de predicción de todos los modelos
@app.post("/Modelos/Plot")
async def obtener_grafica_errores(indice:str,freq:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20 % finales) y los datos predecidos usando los distintos modelos:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    train = int(df.shape[0]*0.8)  
    
    #Forecaster con Random Forest
    forecasterRF = ForecasterAutoreg(
        regressor = RandomForestRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectRF = ForecasterAutoregDirect(
        regressor = RandomForestRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridRF = [10, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridRF = {
        'n_estimators': [100, 200, 500],
        'max_depth': [ 10, 20, 30],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2'],
    }
                
    # Forecaster con Gradient Boosting
    forecasterGB = ForecasterAutoreg(
            regressor = GradientBoostingRegressor(random_state=123),
            lags      = 10
    )
    
    forecasterDirectGB = ForecasterAutoregDirect(
            regressor = GradientBoostingRegressor(random_state=123),
            steps     = df[train:].shape[0],
            lags      = 10
    )
    # Valores candidatos de lags
    lags_gridGB = [10, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridGB = {
        'n_estimators': [100, 200, 300],
        'learning_rate': [0.01, 0.1, 1.0],
        'max_depth': [3, 5, 7],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2']
        } 
    
    # Forecaster con ExtraTree
    forecasterET = ForecasterAutoreg(
        regressor = ExtraTreesRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectET = ForecasterAutoregDirect(
        regressor = ExtraTreesRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridET = [10, 20]

    param_gridET = {
        'n_estimators': [100, 200, 500],
        'max_depth': [ 10, 20, 30],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'max_features': [None, 'sqrt', 'log2'],
    } 
   
    # Forecaster con DT
    forecasterDT = ForecasterAutoreg(
        regressor = DecisionTreeRegressor(random_state=123),
        lags      = 10
    )
    
    forecasterDirectDT = ForecasterAutoregDirect(
        regressor = DecisionTreeRegressor(random_state=123),
        steps     = df[train:].shape[0],
        lags      = 10
    )
    # Valores candidatos de lags
    lags_gridDT = [10, 20]

    param_gridDT = {
        'max_depth': [None, 5, 10, 20, 30],
        'min_samples_split': [2, 5, 10, 15],
        'min_samples_leaf': [1, 2, 5, 10],
        'max_features': [None, 'sqrt', 'log2']
    } 
    
    #Forecaster con Ridge
    forecasterRidge = ForecasterAutoreg(
                    regressor     = Ridge(random_state=123),
                    transformer_y = StandardScaler(),
                    lags          = 5
                )
    forecasterDirectRidge = ForecasterAutoregDirect(
        regressor     = Ridge(random_state=123),
        transformer_y = StandardScaler(),
        steps         = df[train:].shape[0],
        lags          = 5
    )
    # Valores candidatos de lags
    lags_gridRidge = [5, 12, 20]

    # Valores candidatos de hiperparámetros del regresor
    param_gridRidge = {'alpha': np.logspace(-5, 5, 10)}
    
    y_pred4 = pred_prophet_prediccion(df[:train],df.columns[0],df[train:].shape[0],freq)
    y_pred2_1 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df[train:].shape[0],180,param_gridRF,lags_gridRF,forecasterRF)[:df[train:].shape[0]]
    y_pred2_0 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df[train:].shape[0],180,param_gridDT,lags_gridDT,forecasterDT)[:df[train:].shape[0]]
    y_pred2_2 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df[train:].shape[0],180,param_gridGB,lags_gridGB,forecasterGB)[:df[train:].shape[0]]
    y_pred2_3 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df[train:].shape[0],180,param_gridET,lags_gridET,forecasterET)[:df[train:].shape[0]]
    y_pred2_4 = prediccion_backtesting_forecasterAutoreg(df[:train],df.columns[0],df[train:].shape[0],180,param_gridRidge,lags_gridRidge,forecasterRidge)[:df[train:].shape[0]]
    y_pred1=prediccion_sarimax(df,df[:train], df.columns[0])[:df[train:].shape[0]]
    y_pred3_1 = predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0],df[train:].shape[0],param_gridRF,lags_gridRF,forecasterDirectRF)[:df[train:].shape[0]]
    y_pred3_0 = predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0],df[train:].shape[0],param_gridDT,lags_gridDT,forecasterDirectDT)[:df[train:].shape[0]]
    y_pred3_2 = predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0],df[train:].shape[0],param_gridGB,lags_gridGB,forecasterDirectGB)[:df[train:].shape[0]]
    y_pred3_3 = predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0],df[train:].shape[0],param_gridET,lags_gridET,forecasterDirectET)[:df[train:].shape[0]]
    y_pred3_4 = predicciones_backtesting_forecasterAutoregDirect(df[:train],df.columns[0],df[train:].shape[0],param_gridRidge,lags_gridRidge,forecasterDirectRidge)[:df[train:].shape[0]]

    plt.figure()
    y_true=df[train:].values
    result = pd.DataFrame({
        'Valores Reales': y_true.reshape(-1),
        'Predicciones autorregresivos Sarimax': y_pred1.values.reshape(-1),
        'Predicciones forecaster autorregresivo con regresor Decision Tree': y_pred2_0.values.reshape(-1),
        'Predicciones forecaster autorregresivo con regresor Random Forest': y_pred2_1.values.reshape(-1),
        'Predicciones forecaster autorregresivo con regresor Gradient Boosting': y_pred2_2.values.reshape(-1),
        'Predicciones forecaster autorregresivo con regresor Extra Tree': y_pred2_3.values.reshape(-1),
        'Predicciones forecaster autorregresivo con regresor lineal con penalización Ridge': y_pred2_4.values.reshape(-1),
        'Predicciones forecaster directo autorregresivo con regresor Decision Tree': y_pred3_0.values.reshape(-1),
        'Predicciones forecaster directo autorregresivo con regresor Random Forest': y_pred3_1.values.reshape(-1),
        'Predicciones forecaster directo autorregresivo con regresor Gradient Boosting': y_pred3_2.values.reshape(-1),
        'Predicciones forecaster directo autorregresivo con regresor Extra Tree': y_pred3_3.values.reshape(-1),
        'Predicciones forecaster directo autorregresivo con regresor lineal con penalización Ridge': y_pred3_4.values.reshape(-1),
        'Predicciones Prophet': y_pred4
    })
    result.index=df[train:].index
    result.plot(title="Predicciones Modelos",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio de regresión lineal
@app.post("/Error/RegLineal")
async def obtener_error(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y datos predecidos con el modelo de regresión lineal :
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    return {error_entrenar_linearReg(df,columna) }

# Gráfica modelo de regresión lineal
@app.post("/Plot/RegLineal")
async def obtener_grafica(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con el modelo de regresión lineal graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    result = pred_entrenar_linearReg(df,columna)
    plt.figure()
    result[[columna,'Predicciones']].plot(title="Predicciones Modelo Regresión Lineal",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Error cuadrático medio modelo árbol de decisión
@app.post("/Error/DecisionTree")
async def obtener_error(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y datos predecidos con el modelo de árbol de decisión :
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    return {error_entrenar_TreeReg(df,columna) }

# Gráfica modelo árbol de decisión
@app.post("/Plot/DecisionTree")
async def obtener_grafica(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con el modelo de árbol de decisión graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    result = pred_entrenar_TreeReg(df,columna)
    plt.figure()
    result[[columna,'Predicciones']].plot(title="Predicciones Modelo Regresivo Arbol Decisión",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio modelo Random Forest
@app.post("/Error/RandomForest")
async def obtener_error(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """          
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y los datos predecidos con el modelo Random Forest:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    return {error_entrenar_RandomForestReg(df,columna) }

# Gráfica modelo Random Forest
@app.post("/Plot/RandomForest")
async def obtener_grafica(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con el modelo Random Forest graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    result = pred_entrenar_RandomForestReg(df,columna)
    plt.figure()
    result[[columna,'Predicciones']].plot(title="Predicciones Modelo Regresivo Random Forest",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Error modelo Gradient Boosting
@app.post("/Error/GradientBoosting")
async def obtener_error(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y los predecidos con el modelo Gradient Boosting :
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    return {error_entrenar_GradientBoostReg(df,columna) }

# Gráfica modelo Gradient Boosting
@app.post("/Plot/GradientBoosting")
async def obtener_grafica(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con el modelo de gradient boosting graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    result = pred_entrenar_GradientBoostReg(df,columna)
    plt.figure()
    result[[columna,'Predicciones']].plot(title="Predicciones Modelo Regresivo Gradient Boosting",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio modelo Extra Tree
@app.post("/Error/ExtraTree")
async def obtener_error(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y los predecidos con el modelo extra tree :
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    return {error_entrenar_ExtraTreeReg(df,columna) }

# Gráfica modelo Extra Tree
@app.post("/Plot/ExtraTree")
async def obtener_grafica(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con el modelo Extra Tree graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    result = pred_entrenar_ExtraTreeReg(df,columna)
    plt.figure()
    result[[columna,'Predicciones']].plot(title="Predicciones Modelo Regresivo ExtraTree",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")

# Error cuadrático medio que comete cada modelo
@app.post("/Modelos/Error")
async def obtener_errores(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve el error cuadrático medio entre los datos de test (20% finales) y todos los modelos vistos:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    return {"Error regresión Lineal":error_entrenar_linearReg(df,columna) ,
            "Error árbol de decisión":error_entrenar_TreeReg(df,columna),
            "Error random forest":error_entrenar_RandomForestReg(df,columna),
            "Error gradient boosting":error_entrenar_GradientBoostReg(df,columna),
            "Error extra tree":error_entrenar_ExtraTreeReg(df,columna)}
    
# Gráfica con los valores reales vs los valores de predicción de cada modelo
@app.post("/Plot/Modelos")
async def obtener_grafica_errores(indice:str,freq:str,columna:str, file: UploadFile = File(...)) :
    """
    Devuelve una imagen con los datos de test (20% finales) y los datos predecidos con los modelos graficados:
    - **freq**: frecuencia de los datos. Valores posibles: B business day frequency, D calendar day frequency, W weekly frequency, M monthly frequency, Q quarterly frequency, Y yearly frequency, h hourly frequency, min minutely frequency, s secondly frequency, ms milliseconds, us microseconds, ns nanoseconds
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    - **columna**: nombre de la columna que se predice
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    df.index = pd.to_datetime(df.index)
    df.index.freq=freq
    
    result1 = pred_entrenar_linearReg(df,columna)
    res1 = result1['Predicciones'].values.reshape(-1)
    result2 = pred_entrenar_TreeReg(df,columna)
    res2 = result2['Predicciones'].values.reshape(-1)
    result3 = pred_entrenar_RandomForestReg(df,columna)
    res3 = result3['Predicciones'].values.reshape(-1)
    result4 = pred_entrenar_GradientBoostReg(df,columna)
    res4 = result4['Predicciones'].values.reshape(-1)
    result5 = pred_entrenar_ExtraTreeReg(df,columna)
    res5 = result5['Predicciones'].values.reshape(-1)

    result = pd.DataFrame({
        'Valores Reales': result1[columna].values.reshape(-1),
        'Predicciones regresión lineal': res1,
        'Predicciones árbol decisión': res2,
        'Predicciones random forest': res3,
        'Predicciones gradient boosting': res4,
        'Predicciones extra tree': res5
    })
    result.index = result1.index
    plt.figure()
    result.plot(title="Predicciones Modelos",figsize=(13,7))
    plt.xlabel("Tiempo")  
    buffer = io.BytesIO()
    plt.savefig(buffer,format="png")
    buffer.seek(0)
    plt.close()
    return StreamingResponse(buffer,media_type="image/png")


# Detección de drift mediante Kolmogorov-Smirnov
@app.post("/Deteccion/KS")
async def detectar_drift(indice:str,threshold_ks: float = 0.05, inicio: int = 1, file: UploadFile = File(...)) :
    """
    Devuelve una dupla (Drfit,reporte) donde Drift indica si se ha detectado drift mediante la técnica de Kolmogorov-Smirnov y el reporte informa en que columna se ha detectado el drift:
    - **threshold_ks**: úmbral de detección
    - **inicio**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    Nota: la comparativa entre las distribuciones se realiza dividiendo en dos mitades el dataframe desde la posición de inicio
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    sep = int((df.shape[0]-inicio)*0.5)
    deteccion,reporte = detect_dataset_drift_ks(df[inicio:sep],df[sep:],threshold_ks)
    return {"Drift": deteccion, "reporte":reporte}


# Detección de drift mediante Jensen-Shannon
@app.post("/Deteccion/JS")
async def detectar_drift(indice:str,threshold_js: float = 0.2,inicio:int=1, file: UploadFile = File(...)) :
    """
    Devuelve una dupla (Drift,reporte) donde Drift indica si se ha detectado drift mediante la técnica de Jensen-Shannon y el reporte informa en que columna se ha detectado el drift:
    - **threshold_js**: úmbral de detección
    - **inicio**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    Nota: la comparativa entre las distribuciones se realiza dividiendo en dos mitades el dataframe desde la posición de inicio
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    sep = int((df.shape[0]-inicio)*0.5)
    deteccion,reporte = detect_dataset_drift_js(df[inicio:sep],df[sep:],threshold_js)
    return {"Drift": deteccion, "reporte":reporte}

# Detección de drift usando Population Stability Index
@app.post("/Deteccion/PSI")
async def detectar_drift(indice:str,threshold_psi: float = 2,num_bins :int =10,inicio:int=1, file: UploadFile = File(...)) :
    """
    Devuelve una dupla (Drift,reporte) donde Drift indica si se ha detectado drift mediante el Population Stability Index y el reporte informa en que columna se ha detectado el drift:
    - **threshold_psi**: úmbral de detección
    - **inicio**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **num_bins**: número de cajas en la que se divide los datos
    - **file** : csv con los datos 
    Nota: la comparativa entre las distribuciones se realiza dividiendo el dataframe desde la posición de inicio en dos: 80% y 20%
    """    
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")

    sep = int((df.shape[0]-inicio)*0.8)
    deteccion,reporte = detect_dataset_drift_psi(df[inicio:sep],df[sep:],threshold_psi,num_bins)
    return {"Drift": deteccion, "reporte":reporte}


# Detección de drift usando Population Stability Index con cuantiles
@app.post("/Deteccion/PSI/Cuantiles")
async def detectar_drift(indice:str,threshold_psi: float = 2,num_quantiles :int =10,inicio:int=1, file: UploadFile = File(...)) :
    """
    Devuelve una dupla (Drift,reporte) donde Drift indica si se ha detectado drift mediante el Population Stability Index dividiendo en cuantiles y el reporte informa en que columna se ha detectado el drift:
    - **threshold_psi**: úmbral de detección
    - **inicio**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **num_bins**: número de cuantiles
    - **file** : csv con los datos 
    Nota: la comparativa entre las distribuciones se realiza dividiendo el dataframe desde la posición de inicio en dos: 80% y 20%
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    sep = int((df.shape[0]-inicio)*0.8)
    deteccion,reporte = detect_dataset_drift_psi_quantiles(df[inicio:sep],df[sep:],threshold_psi,num_quantiles)
    return {"Drift": deteccion, "reporte":reporte}


# Detección de drift usando CUSUM
@app.post("/Deteccion/CUSUM")
async def detectar_drift(indice:str,threshold_cusum: float = 1.5,drift_cusum :float = 0.5,inicio:int=1, file: UploadFile = File(...)) :
    """
    Devuelve si se detectado drift o no usando la técnica CUSUM:
    - **threshold_cusum**: úmbral de detección
    - **drift_cusum**: sensibilidad del modelo
    - **inicio**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **file** : csv con los datos 
    """       
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    deteccion,reporte = detect_dataset_drift_cusum(df[inicio:],threshold_cusum,drift_cusum)
    return {"Drift": deteccion, "reporte":reporte}


# Detección de drift usando Page Hinkley
@app.post("/Deteccion/PH")
async def detectar_drift(indice:str,min_instances:int=30, delta:float=0.005, threshold:float=50, alpha:float=1 - 0.0001, file: UploadFile = File(...)) :
    """
    Devuelve una dupla (Drift,reporte) donde Drift indica si se ha detectado drift mediante el método Page-Hinkley y el reporte informa en que columna se ha detectado el drift:
    - **threshold**: úmbral de detección
    - **min_instances**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **delta**: umbral de ruido
    - **alpha**: tasa de penalización
    - **file** : csv con los datos 
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    deteccion,reporte = detect_dataset_drift_ph(df,min_instances, delta, threshold,alpha)
    return {"Drift": deteccion, "reporte":reporte}

# Detección de drift usando MCUSUM
@app.post("/Deteccion/MCUSUM")
async def detectar_drift(indice:str,min_instances:int=100, lambd:float=0.5, file: UploadFile = File(...)) :
    """
    Devuelve si se ha detectado drift mediante el método MCUSUM:
    - **min_instances**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **lambda**: parámetro de de sensibilidad del modelo
    - **file** : csv con los datos multivariables
    """   
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    drift_status = detect_dataset_drift_mcusum(df,min_instances,lambd)
    if drift_status:
        drift = "Detectado"
    else: 
        drift = "No detectado"
    return {"Drift": drift}

# Detección de drift usando MEWMA y las componentes principales
@app.post("/Deteccion/PC_MEWMA")
async def detectar_drift(indice:str,princ_comp:int,min_instances:int=100, lambd:float=0.5,alpha:float=0, file: UploadFile = File(...)) :
    """
    Devuelve si se ha detectado drift mediante el método Mewma usando las componentes principales:
    - **min_instances**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **princ_comp**: número de componentes principales
    - **lambda**: Peso del promedio exponencial, parámetro de suavización entre 0 y 1. 
    - **alpha**: Nivel de significación, porcentaje de falsos positivos permitidos
    - **file** : csv con los datos multivariables
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    drift_status = detect_dataset_drift_pC_mewma(df,princ_comp,min_instances,lambd,alpha)
    if drift_status:
        drift = "Detectado"
    else: 
        drift = "No detectado"
    return {"Drift": drift}



# Detección de drift usando MEWMA
@app.post("/Deteccion/MEWMA")
async def detectar_drift(indice:str,min_instances:int=100, lambd:float=0.5,alpha:float=0, file: UploadFile = File(...)) :
    """
    Devuelve si se ha detectado drift mediante el método MEWMA:
    - **min_instances**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **lambda**: Peso del promedio exponencial, parámetro de suavización entre 0 y 1. 
    - **alpha**: Nivel de significación, porcentaje de falsos positivos permitidos
    - **file** : csv con los datos multivariables
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    drift_status = detect_dataset_drift_mewma(df,min_instances,lambd,alpha)
    if drift_status:
        drift = "Detectado"
    else: 
        drift = "No detectado"
    return {"Drift": drift}


# Detección de drift usando Hotelling
@app.post("/Deteccion/HOTELLING")
async def detectar_drift(indice:str,min_instances:int=100,alpha:float=0, file: UploadFile = File(...)) :
    """
    Devuelve si se ha detectado drift mediante el método Hotelling:
    - **min_instances**: dato desde el que se comienza a buscar el drift
    - **indice** : nombre de la columna que se usa como índice en el csv
    - **alpha**: nivel de significación, porcentaje de falsos positivos aceptados
    - **file** : csv con los datos multivariables
    """
    if file.content_type != 'text/csv':
        raise HTTPException(status_code=400, detail="El archivo debe ser un CSV")

    try:
        contents = await file.read()
        csv_data = StringIO(contents.decode('utf-8'))
        df = pd.read_csv(csv_data,index_col=indice)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error al leer el archivo CSV: {e}")
    
    drift_status = detect_dataset_drift_hotelling(df,min_instances,alpha)
    if drift_status:
        drift = "Detectado"
    else: 
        drift = "No detectado"
    return {"Drift": drift}